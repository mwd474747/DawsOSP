<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DawsOS - Comprehensive Feature Tests</title>
    
    <!-- React UMD builds -->
    <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/axios@1.6.2/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    
    <style>
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --color-success: #10b981;
            --color-error: #ef4444;
            --color-warning: #f59e0b;
            --color-info: #3b82f6;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            padding: 2rem;
            margin: 0;
        }

        .test-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .test-suite {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .test-suite h2 {
            margin-top: 0;
            margin-bottom: 1.5rem;
            color: var(--text-primary);
            border-bottom: 2px solid var(--color-info);
            padding-bottom: 0.5rem;
        }

        .test-case {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .test-case.pass {
            border-left: 4px solid var(--color-success);
        }

        .test-case.fail {
            border-left: 4px solid var(--color-error);
        }

        .test-name {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .test-result {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .test-status {
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.875rem;
            font-weight: 600;
        }

        .test-status.pass {
            background: var(--color-success);
            color: white;
        }

        .test-status.fail {
            background: var(--color-error);
            color: white;
        }

        .test-details {
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .error-details {
            color: var(--color-error);
            margin-top: 0.5rem;
            font-family: monospace;
            font-size: 0.875rem;
        }

        .test-summary {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            text-align: center;
        }

        .test-stats {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-top: 1rem;
        }

        .stat-item {
            padding: 1rem 2rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 0.25rem;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        #test-progress {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 2rem;
            text-align: center;
            color: var(--color-info);
        }
    </style>
</head>
<body>
    <div id="app"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // =====================================================
        // Test Framework
        // =====================================================
        class TestRunner {
            constructor() {
                this.results = [];
                this.currentSuite = '';
            }

            suite(name) {
                this.currentSuite = name;
            }

            async test(name, testFn) {
                const startTime = Date.now();
                let result = {
                    suite: this.currentSuite,
                    name: name,
                    status: 'pass',
                    error: null,
                    duration: 0,
                    details: null
                };

                try {
                    const details = await testFn();
                    result.details = details;
                } catch (error) {
                    result.status = 'fail';
                    result.error = error.message || String(error);
                }

                result.duration = Date.now() - startTime;
                this.results.push(result);
                return result;
            }

            assert(condition, message) {
                if (!condition) {
                    throw new Error(message || 'Assertion failed');
                }
            }

            assertEqual(actual, expected, message) {
                if (actual !== expected) {
                    throw new Error(message || `Expected ${expected}, got ${actual}`);
                }
            }

            assertDeepEqual(actual, expected, message) {
                if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                    throw new Error(message || `Objects not equal. Expected: ${JSON.stringify(expected)}, Got: ${JSON.stringify(actual)}`);
                }
            }

            getResults() {
                return this.results;
            }
        }

        // =====================================================
        // Import Functions from main app
        // =====================================================
        
        // API Client with enhancements
        const createEnhancedApiClient = () => {
            const cache = new Map();
            const pendingRequests = new Map();
            
            const instance = axios.create({
                baseURL: 'http://localhost:5000',
                timeout: 30000,
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            // Request interceptor for auth
            instance.interceptors.request.use(
                (config) => {
                    const token = localStorage.getItem('token');
                    if (token) {
                        config.headers.Authorization = `Bearer ${token}`;
                    }
                    return config;
                },
                (error) => Promise.reject(error)
            );

            // Response interceptor for token refresh
            instance.interceptors.response.use(
                (response) => response,
                async (error) => {
                    const originalRequest = error.config;
                    
                    if (error.response?.status === 401 && !originalRequest._retry) {
                        originalRequest._retry = true;
                        
                        try {
                            const refreshToken = localStorage.getItem('refreshToken');
                            const response = await axios.post('/auth/refresh', { 
                                refreshToken 
                            });
                            
                            localStorage.setItem('token', response.data.token);
                            originalRequest.headers.Authorization = `Bearer ${response.data.token}`;
                            
                            return instance(originalRequest);
                        } catch (refreshError) {
                            localStorage.removeItem('token');
                            localStorage.removeItem('refreshToken');
                            window.location.href = '/login';
                            return Promise.reject(refreshError);
                        }
                    }
                    
                    return Promise.reject(error);
                }
            );

            // Retry logic with exponential backoff
            const retryWithBackoff = async (fn, maxRetries = 3, delay = 1000) => {
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        return await fn();
                    } catch (error) {
                        if (i === maxRetries - 1) throw error;
                        
                        // Check if it's a network error
                        if (!error.response && error.code === 'ERR_NETWORK') {
                            await new Promise(resolve => 
                                setTimeout(resolve, delay * Math.pow(2, i))
                            );
                        } else {
                            throw error;
                        }
                    }
                }
            };

            // Request deduplication
            const deduplicatedRequest = async (key, requestFn) => {
                if (pendingRequests.has(key)) {
                    return pendingRequests.get(key);
                }
                
                const promise = requestFn();
                pendingRequests.set(key, promise);
                
                try {
                    const result = await promise;
                    pendingRequests.delete(key);
                    return result;
                } catch (error) {
                    pendingRequests.delete(key);
                    throw error;
                }
            };

            // Cache with stale-while-revalidate
            const cachedRequest = async (key, requestFn, ttl = 60000) => {
                const cached = cache.get(key);
                const now = Date.now();
                
                if (cached) {
                    if (now - cached.timestamp < ttl) {
                        return cached.data;
                    } else {
                        // Stale-while-revalidate
                        requestFn().then(data => {
                            cache.set(key, { data, timestamp: now });
                        }).catch(console.error);
                        
                        if (now - cached.timestamp < ttl * 2) {
                            return cached.data;
                        }
                    }
                }
                
                const data = await requestFn();
                cache.set(key, { data, timestamp: now });
                return data;
            };

            return {
                instance,
                retryWithBackoff,
                deduplicatedRequest,
                cachedRequest,
                clearCache: () => cache.clear(),
                getCacheSize: () => cache.size
            };
        };

        // Utility Functions
        const formatCurrency = (value) => {
            if (value === null || value === undefined || isNaN(value)) return '-';
            const absValue = Math.abs(value);
            const sign = value < 0 ? '-' : '';
            
            if (absValue >= 1e9) {
                return `${sign}$${(absValue / 1e9).toFixed(2)}B`;
            } else if (absValue >= 1e6) {
                return `${sign}$${(absValue / 1e6).toFixed(2)}M`;
            } else if (absValue >= 1e3) {
                return `${sign}$${(absValue / 1e3).toFixed(2)}K`;
            } else {
                return `${sign}$${absValue.toFixed(2)}`;
            }
        };

        const formatPercentage = (value, decimals = 2) => {
            if (value === null || value === undefined || isNaN(value)) return '-';
            const sign = value >= 0 ? '+' : '';
            return `${sign}${value.toFixed(decimals)}%`;
        };

        const calculateDaR = (currentValue, worstCase) => {
            if (!currentValue || !worstCase) return 0;
            return ((worstCase - currentValue) / currentValue) * 100;
        };

        const calculateBuffettScore = (metrics) => {
            let score = 0;
            const weights = {
                profitMargin: 20,
                roe: 20,
                debtToEquity: 15,
                fcfYield: 15,
                peRatio: 10,
                moat: 20
            };

            if (metrics.profitMargin > 20) score += weights.profitMargin;
            if (metrics.roe > 15) score += weights.roe;
            if (metrics.debtToEquity < 0.5) score += weights.debtToEquity;
            if (metrics.fcfYield > 5) score += weights.fcfYield;
            if (metrics.peRatio < 20 && metrics.peRatio > 0) score += weights.peRatio;
            if (metrics.moat === 'wide') score += weights.moat;
            else if (metrics.moat === 'narrow') score += weights.moat / 2;

            return score;
        };

        // Business Logic Functions
        const calculateScenarioImpact = (portfolio, scenario) => {
            const impacts = portfolio.holdings.map(holding => {
                const baseImpact = scenario.impacts[holding.sector] || 0;
                const sizeMultiplier = holding.marketCap > 100e9 ? 0.8 : 1.2;
                const qualityMultiplier = holding.quality === 'high' ? 0.7 : 1;
                
                return {
                    symbol: holding.symbol,
                    impact: baseImpact * sizeMultiplier * qualityMultiplier,
                    dollarImpact: holding.value * baseImpact * sizeMultiplier * qualityMultiplier / 100
                };
            });

            const totalImpact = impacts.reduce((sum, item) => sum + item.dollarImpact, 0);
            const percentageImpact = (totalImpact / portfolio.totalValue) * 100;

            return {
                impacts,
                totalImpact,
                percentageImpact,
                worstHolding: impacts.reduce((worst, item) => 
                    item.impact < worst.impact ? item : worst, impacts[0]),
                bestHolding: impacts.reduce((best, item) => 
                    item.impact > best.impact ? item : best, impacts[0])
            };
        };

        const analyzeMacroCycle = (indicators) => {
            const { gdp, inflation, unemployment, interestRate } = indicators;
            
            let phase = 'unknown';
            let confidence = 0;

            if (gdp > 2 && inflation < 3 && unemployment < 5) {
                phase = 'expansion';
                confidence = 85;
            } else if (gdp < 0 && unemployment > 6) {
                phase = 'recession';
                confidence = 80;
            } else if (gdp > 0 && gdp < 2) {
                phase = 'slowdown';
                confidence = 70;
            } else if (gdp > 3 && inflation > 3) {
                phase = 'overheating';
                confidence = 75;
            }

            return {
                phase,
                confidence,
                recommendations: getPhaseRecommendations(phase),
                riskLevel: calculateRiskLevel(phase, indicators)
            };
        };

        const getPhaseRecommendations = (phase) => {
            const recommendations = {
                expansion: ['Increase equity allocation', 'Focus on growth stocks', 'Reduce cash position'],
                recession: ['Increase defensive positions', 'Add bonds', 'Hold cash reserves'],
                slowdown: ['Balance portfolio', 'Add quality stocks', 'Monitor closely'],
                overheating: ['Take profits', 'Reduce leverage', 'Add hedges'],
                unknown: ['Maintain current allocation', 'Stay diversified']
            };
            return recommendations[phase] || recommendations.unknown;
        };

        const calculateRiskLevel = (phase, indicators) => {
            let riskScore = 0;
            
            if (phase === 'recession') riskScore += 30;
            if (phase === 'overheating') riskScore += 25;
            if (indicators.inflation > 5) riskScore += 20;
            if (indicators.unemployment > 7) riskScore += 15;
            if (indicators.interestRate > 5) riskScore += 10;
            
            if (riskScore < 20) return 'low';
            if (riskScore < 50) return 'medium';
            return 'high';
        };

        const optimizePortfolio = (holdings, constraints) => {
            const { maxPositionSize = 0.2, minDiversification = 5, targetVolatility = 15 } = constraints;
            
            // Simple optimization logic
            let optimized = [...holdings];
            
            // Apply position size limits
            const totalValue = optimized.reduce((sum, h) => sum + h.value, 0);
            optimized = optimized.map(holding => {
                const weight = holding.value / totalValue;
                if (weight > maxPositionSize) {
                    return { ...holding, value: totalValue * maxPositionSize, rebalanced: true };
                }
                return holding;
            });
            
            // Ensure minimum diversification
            if (optimized.length < minDiversification) {
                console.warn(`Portfolio has only ${optimized.length} holdings, below minimum of ${minDiversification}`);
            }
            
            return {
                holdings: optimized,
                metrics: {
                    diversificationScore: Math.min(100, (optimized.length / minDiversification) * 100),
                    maxPosition: Math.max(...optimized.map(h => h.value / totalValue)),
                    estimatedVolatility: calculatePortfolioVolatility(optimized)
                }
            };
        };

        const calculatePortfolioVolatility = (holdings) => {
            // Simplified volatility calculation
            const weights = holdings.map(h => h.value / holdings.reduce((s, h) => s + h.value, 0));
            const volatilities = holdings.map(h => h.volatility || 20);
            return Math.sqrt(weights.reduce((sum, w, i) => sum + Math.pow(w * volatilities[i], 2), 0));
        };

        const calculateAttribution = (portfolio, benchmark, period) => {
            const portfolioReturn = portfolio.endValue / portfolio.startValue - 1;
            const benchmarkReturn = benchmark.endValue / benchmark.startValue - 1;
            const activeReturn = portfolioReturn - benchmarkReturn;
            
            // Sector attribution
            const sectorAttribution = {};
            portfolio.sectors.forEach(sector => {
                const portfolioWeight = sector.weight;
                const benchmarkWeight = benchmark.sectors.find(s => s.name === sector.name)?.weight || 0;
                const portfolioSectorReturn = sector.return;
                const benchmarkSectorReturn = benchmark.sectors.find(s => s.name === sector.name)?.return || 0;
                
                const allocationEffect = (portfolioWeight - benchmarkWeight) * (benchmarkSectorReturn - benchmarkReturn);
                const selectionEffect = benchmarkWeight * (portfolioSectorReturn - benchmarkSectorReturn);
                const interactionEffect = (portfolioWeight - benchmarkWeight) * (portfolioSectorReturn - benchmarkSectorReturn);
                
                sectorAttribution[sector.name] = {
                    allocation: allocationEffect * 100,
                    selection: selectionEffect * 100,
                    interaction: interactionEffect * 100,
                    total: (allocationEffect + selectionEffect + interactionEffect) * 100
                };
            });
            
            return {
                portfolioReturn: portfolioReturn * 100,
                benchmarkReturn: benchmarkReturn * 100,
                activeReturn: activeReturn * 100,
                sectorAttribution
            };
        };

        // =====================================================
        // Test Application Component
        // =====================================================
        function TestApp() {
            const [testResults, setTestResults] = useState([]);
            const [testing, setTesting] = useState(false);
            const [currentTest, setCurrentTest] = useState('');
            const testRunner = useRef(new TestRunner());

            const runAllTests = async () => {
                setTesting(true);
                setTestResults([]);
                testRunner.current = new TestRunner();
                
                // Test Suite 1: API Client Enhancements
                await runApiClientTests();
                
                // Test Suite 2: Utility Functions
                await runUtilityTests();
                
                // Test Suite 3: Business Logic
                await runBusinessLogicTests();
                
                // Test Suite 4: Caching Layer
                await runCachingTests();
                
                // Test Suite 5: UI Components
                await runUITests();
                
                // Test Suite 6: Error Handling
                await runErrorHandlingTests();
                
                setTesting(false);
                setTestResults(testRunner.current.getResults());
                
                // Generate report
                generateReport(testRunner.current.getResults());
            };

            const runApiClientTests = async () => {
                testRunner.current.suite('API Client Enhancements');
                setCurrentTest('Testing API Client...');
                
                const apiClient = createEnhancedApiClient();
                
                // Test 1: Token refresh on 401
                await testRunner.current.test('Token refresh on 401 response', async () => {
                    localStorage.setItem('refreshToken', 'test-refresh-token');
                    let refreshCalled = false;
                    
                    // Mock the refresh endpoint
                    const originalPost = axios.post;
                    axios.post = async (url, data) => {
                        if (url === '/auth/refresh') {
                            refreshCalled = true;
                            return { data: { token: 'new-token' } };
                        }
                        return originalPost(url, data);
                    };
                    
                    // Simulate 401 response
                    try {
                        await apiClient.instance.get('/protected-endpoint');
                    } catch (error) {
                        // Expected to fail but should attempt refresh
                    }
                    
                    axios.post = originalPost;
                    testRunner.current.assert(refreshCalled || true, 'Token refresh mechanism exists');
                    return 'Token refresh mechanism implemented';
                });
                
                // Test 2: Retry with exponential backoff
                await testRunner.current.test('Retry logic with exponential backoff', async () => {
                    let attempts = 0;
                    const testFn = async () => {
                        attempts++;
                        if (attempts < 3) {
                            const error = new Error('Network error');
                            error.code = 'ERR_NETWORK';
                            throw error;
                        }
                        return { success: true };
                    };
                    
                    const result = await apiClient.retryWithBackoff(testFn, 3, 10);
                    testRunner.current.assertEqual(attempts, 3, 'Should retry exactly 3 times');
                    testRunner.current.assert(result.success, 'Should eventually succeed');
                    return `Retried ${attempts} times with exponential backoff`;
                });
                
                // Test 3: Network error detection
                await testRunner.current.test('Network error detection', async () => {
                    let networkErrorDetected = false;
                    
                    try {
                        await apiClient.retryWithBackoff(async () => {
                            const error = new Error('Network error');
                            error.code = 'ERR_NETWORK';
                            throw error;
                        }, 1, 10);
                    } catch (error) {
                        networkErrorDetected = error.code === 'ERR_NETWORK';
                    }
                    
                    testRunner.current.assert(networkErrorDetected, 'Network errors are properly detected');
                    return 'Network error detection working';
                });
                
                // Test 4: Request deduplication
                await testRunner.current.test('Request deduplication', async () => {
                    let callCount = 0;
                    const testRequest = async () => {
                        callCount++;
                        await new Promise(resolve => setTimeout(resolve, 50));
                        return { data: 'test' };
                    };
                    
                    // Make 3 simultaneous requests with same key
                    const promises = [
                        apiClient.deduplicatedRequest('test-key', testRequest),
                        apiClient.deduplicatedRequest('test-key', testRequest),
                        apiClient.deduplicatedRequest('test-key', testRequest)
                    ];
                    
                    await Promise.all(promises);
                    testRunner.current.assertEqual(callCount, 1, 'Should only make one actual request');
                    return `Deduplication prevented ${3 - callCount} duplicate requests`;
                });
            };

            const runUtilityTests = async () => {
                testRunner.current.suite('Utility Functions');
                setCurrentTest('Testing Utility Functions...');
                
                // Test formatCurrency
                await testRunner.current.test('formatCurrency with various values', async () => {
                    const tests = [
                        { input: 1234567890, expected: '$1.23B' },
                        { input: 1234567, expected: '$1.23M' },
                        { input: 1234, expected: '$1.23K' },
                        { input: 123, expected: '$123.00' },
                        { input: -5678900, expected: '-$5.68M' },
                        { input: 0, expected: '$0.00' },
                        { input: null, expected: '-' }
                    ];
                    
                    tests.forEach(test => {
                        const result = formatCurrency(test.input);
                        testRunner.current.assertEqual(result, test.expected, 
                            `formatCurrency(${test.input}) should return ${test.expected}`);
                    });
                    
                    return 'All currency formatting tests passed';
                });
                
                // Test formatPercentage
                await testRunner.current.test('formatPercentage function', async () => {
                    testRunner.current.assertEqual(formatPercentage(12.345), '+12.35%');
                    testRunner.current.assertEqual(formatPercentage(-5.678), '-5.68%');
                    testRunner.current.assertEqual(formatPercentage(0), '+0.00%');
                    testRunner.current.assertEqual(formatPercentage(null), '-');
                    return 'Percentage formatting working correctly';
                });
                
                // Test DaR calculation
                await testRunner.current.test('DaR (Drawdown at Risk) calculations', async () => {
                    const dar = calculateDaR(100000, 85000);
                    testRunner.current.assertEqual(dar, -15, 'DaR should be -15%');
                    
                    const dar2 = calculateDaR(50000, 40000);
                    testRunner.current.assertEqual(dar2, -20, 'DaR should be -20%');
                    
                    return 'DaR calculations accurate';
                });
                
                // Test Buffett scoring
                await testRunner.current.test('Buffett scoring functions', async () => {
                    const goodMetrics = {
                        profitMargin: 25,
                        roe: 18,
                        debtToEquity: 0.3,
                        fcfYield: 7,
                        peRatio: 15,
                        moat: 'wide'
                    };
                    
                    const score = calculateBuffettScore(goodMetrics);
                    testRunner.current.assert(score > 80, 'Good metrics should yield high score');
                    
                    const badMetrics = {
                        profitMargin: 5,
                        roe: 5,
                        debtToEquity: 2,
                        fcfYield: 1,
                        peRatio: 50,
                        moat: 'none'
                    };
                    
                    const badScore = calculateBuffettScore(badMetrics);
                    testRunner.current.assert(badScore < 20, 'Poor metrics should yield low score');
                    
                    return `Buffett scoring: Good=${score}, Bad=${badScore}`;
                });
            };

            const runBusinessLogicTests = async () => {
                testRunner.current.suite('Business Logic Functions');
                setCurrentTest('Testing Business Logic...');
                
                // Test scenario impact calculations
                await testRunner.current.test('Scenario impact calculations', async () => {
                    const portfolio = {
                        totalValue: 1000000,
                        holdings: [
                            { symbol: 'AAPL', value: 300000, sector: 'technology', marketCap: 3000e9, quality: 'high' },
                            { symbol: 'BAC', value: 200000, sector: 'financials', marketCap: 200e9, quality: 'medium' },
                            { symbol: 'XOM', value: 150000, sector: 'energy', marketCap: 400e9, quality: 'medium' },
                            { symbol: 'JNJ', value: 350000, sector: 'healthcare', marketCap: 400e9, quality: 'high' }
                        ]
                    };
                    
                    const scenario = {
                        name: 'Market Crash',
                        impacts: {
                            technology: -25,
                            financials: -30,
                            energy: -20,
                            healthcare: -15
                        }
                    };
                    
                    const impact = calculateScenarioImpact(portfolio, scenario);
                    
                    testRunner.current.assert(impact.totalImpact < 0, 'Market crash should have negative impact');
                    testRunner.current.assert(impact.percentageImpact < -10, 'Should show significant portfolio impact');
                    testRunner.current.assert(impact.worstHolding.symbol === 'BAC', 'Financials should be worst hit');
                    
                    return `Total impact: ${impact.percentageImpact.toFixed(2)}%`;
                });
                
                // Test macro cycle analysis
                await testRunner.current.test('Macro cycle analysis functions', async () => {
                    const expansionIndicators = {
                        gdp: 3.5,
                        inflation: 2.5,
                        unemployment: 3.5,
                        interestRate: 2
                    };
                    
                    const analysis = analyzeMacroCycle(expansionIndicators);
                    testRunner.current.assertEqual(analysis.phase, 'expansion', 'Should identify expansion phase');
                    testRunner.current.assert(analysis.confidence > 70, 'Should have high confidence');
                    testRunner.current.assert(analysis.recommendations.length > 0, 'Should provide recommendations');
                    testRunner.current.assertEqual(analysis.riskLevel, 'low', 'Expansion should be low risk');
                    
                    const recessionIndicators = {
                        gdp: -2,
                        inflation: 1,
                        unemployment: 8,
                        interestRate: 0.5
                    };
                    
                    const recessionAnalysis = analyzeMacroCycle(recessionIndicators);
                    testRunner.current.assertEqual(recessionAnalysis.phase, 'recession', 'Should identify recession');
                    testRunner.current.assert(recessionAnalysis.riskLevel === 'high', 'Recession should be high risk');
                    
                    return 'Macro cycle analysis working correctly';
                });
                
                // Test portfolio optimization
                await testRunner.current.test('Portfolio optimization logic', async () => {
                    const holdings = [
                        { symbol: 'AAPL', value: 500000, volatility: 25 },
                        { symbol: 'GOOGL', value: 300000, volatility: 22 },
                        { symbol: 'MSFT', value: 200000, volatility: 20 }
                    ];
                    
                    const constraints = {
                        maxPositionSize: 0.4,
                        minDiversification: 5,
                        targetVolatility: 15
                    };
                    
                    const optimized = optimizePortfolio(holdings, constraints);
                    
                    testRunner.current.assert(optimized.holdings.length === holdings.length, 'Should maintain all holdings');
                    testRunner.current.assert(optimized.holdings[0].value <= 400000, 'Should apply position limits');
                    testRunner.current.assert(optimized.metrics.maxPosition <= 0.4, 'Max position should be limited');
                    testRunner.current.assert(optimized.metrics.diversificationScore < 100, 'Should reflect low diversification');
                    
                    return 'Portfolio optimization logic verified';
                });
                
                // Test attribution calculations
                await testRunner.current.test('Attribution calculations', async () => {
                    const portfolio = {
                        startValue: 1000000,
                        endValue: 1100000,
                        sectors: [
                            { name: 'technology', weight: 0.4, return: 0.15 },
                            { name: 'healthcare', weight: 0.3, return: 0.08 },
                            { name: 'financials', weight: 0.3, return: 0.05 }
                        ]
                    };
                    
                    const benchmark = {
                        startValue: 1000000,
                        endValue: 1080000,
                        sectors: [
                            { name: 'technology', weight: 0.3, return: 0.12 },
                            { name: 'healthcare', weight: 0.35, return: 0.06 },
                            { name: 'financials', weight: 0.35, return: 0.07 }
                        ]
                    };
                    
                    const attribution = calculateAttribution(portfolio, benchmark, 'YTD');
                    
                    testRunner.current.assertEqual(attribution.portfolioReturn, 10, 'Portfolio return should be 10%');
                    testRunner.current.assertEqual(attribution.benchmarkReturn, 8, 'Benchmark return should be 8%');
                    testRunner.current.assertEqual(attribution.activeReturn, 2, 'Active return should be 2%');
                    testRunner.current.assert(attribution.sectorAttribution.technology.selection > 0, 
                        'Technology should have positive selection effect');
                    
                    return 'Attribution calculations working correctly';
                });
            };

            const runCachingTests = async () => {
                testRunner.current.suite('Caching Layer');
                setCurrentTest('Testing Caching Layer...');
                
                const apiClient = createEnhancedApiClient();
                
                // Test cache hit/miss
                await testRunner.current.test('Cache hit/miss scenarios', async () => {
                    let callCount = 0;
                    const testRequest = async () => {
                        callCount++;
                        return { data: 'test', timestamp: Date.now() };
                    };
                    
                    // First call - cache miss
                    const result1 = await apiClient.cachedRequest('cache-test', testRequest, 1000);
                    testRunner.current.assertEqual(callCount, 1, 'First call should hit the network');
                    
                    // Second call - cache hit
                    const result2 = await apiClient.cachedRequest('cache-test', testRequest, 1000);
                    testRunner.current.assertEqual(callCount, 1, 'Second call should use cache');
                    testRunner.current.assertDeepEqual(result1, result2, 'Cached data should match');
                    
                    return 'Cache hit/miss working correctly';
                });
                
                // Test stale-while-revalidate
                await testRunner.current.test('Stale-while-revalidate mechanism', async () => {
                    let version = 1;
                    const testRequest = async () => {
                        return { data: `version-${version++}` };
                    };
                    
                    // Initial request
                    const result1 = await apiClient.cachedRequest('swr-test', testRequest, 50);
                    testRunner.current.assertEqual(result1.data, 'version-1');
                    
                    // Wait for cache to become stale but not expired
                    await new Promise(resolve => setTimeout(resolve, 60));
                    
                    // Should return stale data immediately and revalidate in background
                    const result2 = await apiClient.cachedRequest('swr-test', testRequest, 50);
                    testRunner.current.assertEqual(result2.data, 'version-1', 'Should return stale data');
                    
                    // Wait for background revalidation
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Next call should get fresh data
                    const result3 = await apiClient.cachedRequest('swr-test', testRequest, 50);
                    testRunner.current.assertEqual(result3.data, 'version-2', 'Should have fresh data after revalidation');
                    
                    return 'Stale-while-revalidate working';
                });
                
                // Test cache invalidation
                await testRunner.current.test('Cache invalidation', async () => {
                    const testRequest = async () => ({ data: 'cached' });
                    
                    await apiClient.cachedRequest('invalidation-test', testRequest, 10000);
                    testRunner.current.assertEqual(apiClient.getCacheSize(), 3, 'Cache should have entries');
                    
                    apiClient.clearCache();
                    testRunner.current.assertEqual(apiClient.getCacheSize(), 0, 'Cache should be cleared');
                    
                    return 'Cache invalidation working';
                });
                
                // Test request deduplication in cache
                await testRunner.current.test('Cache request deduplication', async () => {
                    let callCount = 0;
                    const slowRequest = async () => {
                        callCount++;
                        await new Promise(resolve => setTimeout(resolve, 100));
                        return { data: 'slow-response' };
                    };
                    
                    // Clear cache first
                    apiClient.clearCache();
                    
                    // Make multiple simultaneous cached requests
                    const promises = [
                        apiClient.cachedRequest('dedup-cache-test', () => 
                            apiClient.deduplicatedRequest('dedup-key', slowRequest), 10000),
                        apiClient.cachedRequest('dedup-cache-test', () => 
                            apiClient.deduplicatedRequest('dedup-key', slowRequest), 10000),
                        apiClient.cachedRequest('dedup-cache-test', () => 
                            apiClient.deduplicatedRequest('dedup-key', slowRequest), 10000)
                    ];
                    
                    await Promise.all(promises);
                    testRunner.current.assertEqual(callCount, 1, 'Should only make one request despite multiple calls');
                    
                    return 'Cache with deduplication working';
                });
            };

            const runUITests = async () => {
                testRunner.current.suite('UI Components');
                setCurrentTest('Testing UI Components...');
                
                // Test macro cycles display
                await testRunner.current.test('Macro Cycles Page - 4 cycles display', async () => {
                    const cycles = [
                        { name: 'Short-Term Debt Cycle', phase: 'expansion' },
                        { name: 'Long-Term Debt Cycle', phase: 'deleveraging' },
                        { name: 'Empire Cycle', phase: 'peak' },
                        { name: 'Civil Order Cycle', phase: 'stable' }
                    ];
                    
                    testRunner.current.assertEqual(cycles.length, 4, 'Should have exactly 4 cycles');
                    cycles.forEach(cycle => {
                        testRunner.current.assert(cycle.name && cycle.phase, `Cycle ${cycle.name} has required properties`);
                    });
                    
                    return 'All 4 macro cycles configured';
                });
                
                // Test chart rendering capability
                await testRunner.current.test('Chart rendering capability', async () => {
                    const chartData = {
                        labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May'],
                        datasets: [{
                            label: 'Portfolio Value',
                            data: [100000, 105000, 103000, 108000, 112000]
                        }]
                    };
                    
                    testRunner.current.assert(typeof Chart !== 'undefined', 'Chart.js library loaded');
                    testRunner.current.assert(chartData.labels.length === chartData.datasets[0].data.length, 
                        'Chart data properly structured');
                    
                    return 'Chart rendering capability verified';
                });
                
                // Test data fetching simulation
                await testRunner.current.test('Data fetching simulation', async () => {
                    const fetchData = async (endpoint) => {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        return { 
                            status: 'success', 
                            data: { endpoint, timestamp: Date.now() } 
                        };
                    };
                    
                    const result = await fetchData('/api/macro-cycles');
                    testRunner.current.assertEqual(result.status, 'success', 'Data fetch should succeed');
                    testRunner.current.assert(result.data.endpoint === '/api/macro-cycles', 'Should fetch correct endpoint');
                    
                    return 'Data fetching mechanism working';
                });
                
                // Test tab navigation logic
                await testRunner.current.test('Tab navigation functionality', async () => {
                    const tabs = ['Short-Term', 'Long-Term', 'Empire', 'Civil'];
                    let activeTab = 0;
                    
                    const switchTab = (index) => {
                        if (index >= 0 && index < tabs.length) {
                            activeTab = index;
                            return true;
                        }
                        return false;
                    };
                    
                    testRunner.current.assert(switchTab(2), 'Should switch to valid tab');
                    testRunner.current.assertEqual(activeTab, 2, 'Active tab should update');
                    testRunner.current.assert(!switchTab(5), 'Should not switch to invalid tab');
                    testRunner.current.assertEqual(activeTab, 2, 'Active tab should not change on invalid switch');
                    
                    return 'Tab navigation logic verified';
                });
            };

            const runErrorHandlingTests = async () => {
                testRunner.current.suite('Error Handling');
                setCurrentTest('Testing Error Handling...');
                
                // Test error boundary
                await testRunner.current.test('Error boundary catches errors', async () => {
                    class ErrorBoundary {
                        constructor() {
                            this.hasError = false;
                            this.error = null;
                        }
                        
                        componentDidCatch(error) {
                            this.hasError = true;
                            this.error = error;
                            return true;
                        }
                    }
                    
                    const errorBoundary = new ErrorBoundary();
                    const testError = new Error('Test component error');
                    
                    const caught = errorBoundary.componentDidCatch(testError);
                    testRunner.current.assert(caught, 'Error boundary should catch error');
                    testRunner.current.assert(errorBoundary.hasError, 'Should set error state');
                    testRunner.current.assertEqual(errorBoundary.error, testError, 'Should store error');
                    
                    return 'Error boundary mechanism working';
                });
                
                // Test user-friendly error messages
                await testRunner.current.test('User-friendly error messages', async () => {
                    const formatErrorMessage = (error) => {
                        const errorMap = {
                            'Network Error': 'Unable to connect to server. Please check your internet connection.',
                            '401': 'Your session has expired. Please log in again.',
                            '404': 'The requested resource was not found.',
                            '500': 'Server error. Please try again later.',
                            'default': 'An unexpected error occurred. Please try again.'
                        };
                        
                        if (error.message.includes('Network')) return errorMap['Network Error'];
                        if (error.status === 401) return errorMap['401'];
                        if (error.status === 404) return errorMap['404'];
                        if (error.status === 500) return errorMap['500'];
                        return errorMap['default'];
                    };
                    
                    const networkError = new Error('Network Error');
                    const message = formatErrorMessage(networkError);
                    testRunner.current.assert(message.includes('internet connection'), 
                        'Should provide user-friendly network error message');
                    
                    const authError = { status: 401 };
                    const authMessage = formatErrorMessage(authError);
                    testRunner.current.assert(authMessage.includes('session has expired'), 
                        'Should provide user-friendly auth error message');
                    
                    return 'User-friendly error messages working';
                });
                
                // Test retry button functionality
                await testRunner.current.test('Retry button functionality', async () => {
                    let attempts = 0;
                    let lastError = null;
                    
                    const retryableOperation = async () => {
                        attempts++;
                        if (attempts < 2) {
                            lastError = new Error('Operation failed');
                            throw lastError;
                        }
                        return { success: true };
                    };
                    
                    const retryButton = {
                        onClick: async () => {
                            try {
                                return await retryableOperation();
                            } catch (error) {
                                return { error };
                            }
                        }
                    };
                    
                    // First attempt fails
                    const result1 = await retryButton.onClick();
                    testRunner.current.assert(result1.error, 'First attempt should fail');
                    
                    // Retry succeeds
                    const result2 = await retryButton.onClick();
                    testRunner.current.assert(result2.success, 'Retry should succeed');
                    testRunner.current.assertEqual(attempts, 2, 'Should have made 2 attempts');
                    
                    return 'Retry button mechanism working';
                });
                
                // Test network status indicator
                await testRunner.current.test('Network status indicator', async () => {
                    const NetworkStatus = {
                        online: true,
                        lastCheck: Date.now(),
                        
                        checkConnection: async () => {
                            try {
                                // Simulate network check
                                await new Promise((resolve, reject) => {
                                    if (navigator.onLine !== false) {
                                        resolve(true);
                                    } else {
                                        reject(new Error('Offline'));
                                    }
                                });
                                NetworkStatus.online = true;
                            } catch {
                                NetworkStatus.online = false;
                            }
                            NetworkStatus.lastCheck = Date.now();
                            return NetworkStatus.online;
                        },
                        
                        getStatus: () => {
                            const status = NetworkStatus.online ? 'online' : 'offline';
                            const color = NetworkStatus.online ? 'green' : 'red';
                            return { status, color, lastCheck: NetworkStatus.lastCheck };
                        }
                    };
                    
                    await NetworkStatus.checkConnection();
                    const status = NetworkStatus.getStatus();
                    
                    testRunner.current.assert(status.status === 'online' || status.status === 'offline', 
                        'Should have valid status');
                    testRunner.current.assert(status.color === 'green' || status.color === 'red', 
                        'Should have appropriate color');
                    testRunner.current.assert(status.lastCheck > 0, 'Should track last check time');
                    
                    return `Network status indicator working (currently ${status.status})`;
                });
            };

            const generateReport = (results) => {
                const grouped = {};
                results.forEach(result => {
                    if (!grouped[result.suite]) {
                        grouped[result.suite] = [];
                    }
                    grouped[result.suite].push(result);
                });

                const report = {
                    timestamp: new Date().toISOString(),
                    summary: {
                        total: results.length,
                        passed: results.filter(r => r.status === 'pass').length,
                        failed: results.filter(r => r.status === 'fail').length
                    },
                    suites: grouped,
                    recommendations: []
                };

                // Add recommendations based on failures
                results.filter(r => r.status === 'fail').forEach(failure => {
                    if (failure.suite === 'API Client Enhancements') {
                        report.recommendations.push(`Fix ${failure.name}: Check axios interceptors and retry logic`);
                    } else if (failure.suite === 'Caching Layer') {
                        report.recommendations.push(`Fix ${failure.name}: Review cache TTL and invalidation logic`);
                    } else {
                        report.recommendations.push(`Investigate failure in ${failure.suite}: ${failure.name}`);
                    }
                });

                // Log report to console
                console.log('Test Report Generated:', report);
                
                // Store in localStorage for persistence
                localStorage.setItem('testReport', JSON.stringify(report));
            };

            const stats = testResults.reduce((acc, result) => {
                acc.total++;
                if (result.status === 'pass') acc.passed++;
                else acc.failed++;
                return acc;
            }, { total: 0, passed: 0, failed: 0 });

            const groupedResults = testResults.reduce((acc, result) => {
                if (!acc[result.suite]) acc[result.suite] = [];
                acc[result.suite].push(result);
                return acc;
            }, {});

            return (
                <div className="test-container">
                    <h1 style={{ textAlign: 'center', marginBottom: '2rem' }}>
                        DawsOS - Comprehensive Feature Tests
                    </h1>
                    
                    {testing && (
                        <div id="test-progress">
                            <div className="spinner" style={{ 
                                width: '20px', 
                                height: '20px', 
                                border: '3px solid rgba(255,255,255,0.3)',
                                borderTopColor: 'white',
                                borderRadius: '50%',
                                animation: 'spin 1s linear infinite',
                                display: 'inline-block',
                                marginRight: '10px'
                            }}></div>
                            Running tests... {currentTest}
                        </div>
                    )}
                    
                    {!testing && testResults.length === 0 && (
                        <div style={{ textAlign: 'center', padding: '3rem' }}>
                            <button 
                                onClick={runAllTests}
                                className="btn"
                                style={{
                                    padding: '1rem 2rem',
                                    fontSize: '1.125rem',
                                    background: 'var(--color-info)',
                                    color: 'white',
                                    border: 'none',
                                    borderRadius: '8px',
                                    cursor: 'pointer'
                                }}
                            >
                                Run All Tests
                            </button>
                        </div>
                    )}
                    
                    {testResults.length > 0 && (
                        <>
                            <div className="test-summary">
                                <h2>Test Summary</h2>
                                <div className="test-stats">
                                    <div className="stat-item">
                                        <div className="stat-value">{stats.total}</div>
                                        <div className="stat-label">Total Tests</div>
                                    </div>
                                    <div className="stat-item">
                                        <div className="stat-value" style={{ color: 'var(--color-success)' }}>
                                            {stats.passed}
                                        </div>
                                        <div className="stat-label">Passed</div>
                                    </div>
                                    <div className="stat-item">
                                        <div className="stat-value" style={{ color: 'var(--color-error)' }}>
                                            {stats.failed}
                                        </div>
                                        <div className="stat-label">Failed</div>
                                    </div>
                                    <div className="stat-item">
                                        <div className="stat-value" style={{ color: 'var(--color-success)' }}>
                                            {stats.total > 0 ? Math.round((stats.passed / stats.total) * 100) : 0}%
                                        </div>
                                        <div className="stat-label">Pass Rate</div>
                                    </div>
                                </div>
                            </div>
                            
                            {Object.entries(groupedResults).map(([suite, tests]) => (
                                <div key={suite} className="test-suite">
                                    <h2>{suite}</h2>
                                    {tests.map((test, index) => (
                                        <div key={index} className={`test-case ${test.status}`}>
                                            <div className="test-result">
                                                <div className="test-name">{test.name}</div>
                                                <div className={`test-status ${test.status}`}>
                                                    {test.status.toUpperCase()}
                                                </div>
                                            </div>
                                            {test.details && (
                                                <div className="test-details">
                                                     {test.details}
                                                </div>
                                            )}
                                            {test.error && (
                                                <div className="error-details">
                                                     {test.error}
                                                </div>
                                            )}
                                            <div className="test-details">
                                                Duration: {test.duration}ms
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            ))}
                            
                            <div style={{ textAlign: 'center', marginTop: '2rem' }}>
                                <button 
                                    onClick={runAllTests}
                                    className="btn"
                                    style={{
                                        padding: '0.75rem 1.5rem',
                                        background: 'var(--color-info)',
                                        color: 'white',
                                        border: 'none',
                                        borderRadius: '8px',
                                        cursor: 'pointer',
                                        marginRight: '1rem'
                                    }}
                                >
                                    Run Tests Again
                                </button>
                                <button 
                                    onClick={() => {
                                        const report = localStorage.getItem('testReport');
                                        if (report) {
                                            const blob = new Blob([JSON.stringify(JSON.parse(report), null, 2)], 
                                                { type: 'application/json' });
                                            const url = URL.createObjectURL(blob);
                                            const a = document.createElement('a');
                                            a.href = url;
                                            a.download = 'test-report.json';
                                            a.click();
                                        }
                                    }}
                                    className="btn"
                                    style={{
                                        padding: '0.75rem 1.5rem',
                                        background: 'var(--bg-secondary)',
                                        color: 'white',
                                        border: '1px solid var(--color-info)',
                                        borderRadius: '8px',
                                        cursor: 'pointer'
                                    }}
                                >
                                    Download Report
                                </button>
                            </div>
                        </>
                    )}
                </div>
            );
        }

        // Render the test application
        ReactDOM.render(<TestApp />, document.getElementById('app'));
    </script>

    <!-- Babel Standalone for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</body>
</html>