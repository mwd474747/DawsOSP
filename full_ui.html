<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DawsOS Portfolio Intelligence Platform</title>
    
    <!-- React UMD builds -->
    <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/axios@1.6.2/dist/axios.min.js"></script>
    <!-- Chart.js for visualizations -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    
    <!-- API Client Module -->
    <script src="frontend/api-client.js"></script>
    
    <!-- Utility Functions Module -->
    <script src="frontend/utils.js"></script>
    <!-- Panel Components Module -->
    <script src="frontend/panels.js"></script>
    <!-- Page Components Module -->
    <script src="frontend/pages.js"></script>
    
    <!-- Professional Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@300;400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="frontend/styles.css">
</head>
<body>
    <div id="root"></div>
    
    <script>
        // Check if React is loaded
        if (typeof React === 'undefined' || typeof ReactDOM === 'undefined') {
            document.getElementById('root').innerHTML = '<div style="padding: 2rem; text-align: center;">Loading React framework...</div>';
            setTimeout(() => location.reload(), 2000);
        } else {
            // Initialize the application
            const { useState, useEffect, useCallback, useRef } = React;
            const e = React.createElement;
            
            // ============================================
            // API Client is now loaded from frontend/api-client.js
            // All API functionality (TokenManager, apiClient, etc.)
            // is available globally from the external module
            // ============================================

            // ============================================
            // Import from External Modules
            // ============================================
            // Utility functions are in DawsOS.Utils namespace
            const {
                formatCurrency,
                formatPercentage,
                formatNumber,
                formatDate,
                formatValue,
                getColorClass,
                LoadingSpinner,
                ErrorMessage,
                EmptyState,
                RetryableError,
                useCachedQuery,
                useCachedMutation
            } = DawsOS.Utils;

            // Panel components are in DawsOS.Panels namespace
            const {
                MetricsGridPanel,
                DataTablePanel,
                ChartPanel,
                TimeSeriesChartPanel,
                ScorecardPanel,
                AlertPanel,
                HoldingsTable
            } = DawsOS.Panels;

            // Page components are in DawsOS.Pages namespace
            const {
                LoginPage,
                DashboardPage,
                DashboardPageLegacy,
                HoldingsPage,
                SecurityDetailPage,
                TransactionsPage,
                PerformancePage,
                MacroCyclesPage,
                ScenariosPage,
                RiskPage,
                AttributionPage,
                OptimizerPage,
                RatingsPage,
                AIInsightsPage,
                AIAssistantPage,
                AlertsPage,
                ReportsPage,
                CorporateActionsPage,
                MarketDataPage,
                SettingsPage
            } = DawsOS.Pages;

            // ===== UNIFIED PATTERN INTEGRATION SYSTEM =====
            
            /**
             * Get the current portfolio ID with fallback
             * This ensures we always have a valid portfolio ID
             */
            function getCurrentPortfolioId() {
                // 1. Check localStorage first for persisted selection
                const savedPortfolioId = localStorage.getItem('selectedPortfolioId');
                if (savedPortfolioId) {
                    console.log('Using saved portfolio ID from localStorage:', savedPortfolioId);
                    return savedPortfolioId;
                }
                
                // 2. Check if user has a portfolio ID in token storage
                const storedUser = TokenManager.getUser();
                if (storedUser && storedUser.default_portfolio_id) {
                    console.log('Using user portfolio ID:', storedUser.default_portfolio_id);
                    return storedUser.default_portfolio_id;
                }
                
                // 3. Use hardcoded fallback portfolio ID
                const fallbackPortfolioId = '64ff3be6-0ed1-4990-a32b-4ded17f0320c';
                console.log('Using fallback portfolio ID:', fallbackPortfolioId);
                return fallbackPortfolioId;
            }
            
            /**
             * Enhanced Portfolio Context Manager for centralized portfolio management
             */
            const UserContext = React.createContext();
            
            // Portfolio Context Manager Provider
            function UserContextProvider({ children }) {
                const [portfolioId, setPortfolioIdState] = useState(null);
                const [user, setUser] = useState(null);
                const [portfolios, setPortfolios] = useState([]);
                const [currentPortfolioData, setCurrentPortfolioData] = useState(null);
                const [loadingPortfolios, setLoadingPortfolios] = useState(false);
                
                // Enhanced setPortfolioId that persists to localStorage and broadcasts changes
                const setPortfolioId = React.useCallback((newPortfolioId) => {
                    if (newPortfolioId && newPortfolioId !== portfolioId) {
                        // Save to localStorage
                        localStorage.setItem('selectedPortfolioId', newPortfolioId);
                        
                        // Update state
                        setPortfolioIdState(newPortfolioId);
                        
                        // Broadcast portfolio change event for components that need to react
                        window.dispatchEvent(new CustomEvent('portfolioChanged', {
                            detail: { portfolioId: newPortfolioId }
                        }));
                        
                        console.log('Portfolio changed to:', newPortfolioId);
                    }
                }, [portfolioId]);
                
                // Load user portfolios
                const loadPortfolios = React.useCallback(async () => {
                    if (!user) return;
                    
                    setLoadingPortfolios(true);
                    try {
                        // For now, we'll use a single portfolio structure
                        // In the future, this can be expanded to fetch multiple portfolios
                        const portfolio = await apiClient.getPortfolio();
                        const metrics = await apiClient.getMetrics(portfolioId);
                        
                        // Create portfolio array from available data
                        const portfolioData = {
                            id: portfolioId,
                            name: user.email ? `${user.email.split('@')[0]}'s Portfolio` : 'Main Portfolio',
                            value: metrics?.current_value || portfolio?.total_value || 0,
                            performance: {
                                ytd: metrics?.ytd_return || 0,
                                oneYear: metrics?.one_year_return || 0
                            }
                        };
                        
                        setPortfolios([portfolioData]);
                        console.log('Loaded portfolio:', portfolioData);
                    } catch (error) {
                        console.error('Failed to load portfolios:', error);
                        // Set a default portfolio structure if API fails
                        setPortfolios([{
                            id: portfolioId,
                            name: 'Default Portfolio',
                            value: 0
                        }]);
                    } finally {
                        setLoadingPortfolios(false);
                    }
                }, [user, portfolioId]);
                
                // Load current portfolio data
                const loadCurrentPortfolioData = React.useCallback(async () => {
                    if (!portfolioId) return;
                    
                    try {
                        // Fetch current portfolio details using available API methods
                        const [portfolio, metrics] = await Promise.all([
                            apiClient.getPortfolio(),
                            apiClient.getMetrics(portfolioId)
                        ]);
                        
                        if (portfolio || metrics) {
                            setCurrentPortfolioData({
                                id: portfolioId,
                                name: user?.email ? `${user.email.split('@')[0]}'s Portfolio` : 'Main Portfolio',
                                value: metrics?.current_value || portfolio?.total_value || 0,
                                performance: {
                                    ytd: metrics?.ytd_return || 0,
                                    oneYear: metrics?.one_year_return || 0
                                }
                            });
                        }
                    } catch (error) {
                        console.error('Failed to load portfolio data:', error);
                    }
                }, [portfolioId, user]);
                
                // Initialize on mount
                useEffect(() => {
                    // Get user from token manager
                    const storedUser = TokenManager.getUser();
                    if (storedUser) {
                        setUser(storedUser);
                    }
                    
                    // Initialize portfolio ID using enhanced function
                    const initialPortfolioId = getCurrentPortfolioId();
                    setPortfolioIdState(initialPortfolioId);
                }, []);
                
                // Load portfolios when user changes
                useEffect(() => {
                    if (user) {
                        loadPortfolios();
                    }
                }, [user, loadPortfolios]);
                
                // Load portfolio data when portfolio changes
                useEffect(() => {
                    if (portfolioId) {
                        loadCurrentPortfolioData();
                    }
                }, [portfolioId, loadCurrentPortfolioData]);
                
                // Method to switch portfolios
                const switchPortfolio = React.useCallback((newPortfolioId) => {
                    setPortfolioId(newPortfolioId);
                }, [setPortfolioId]);
                
                // Clear portfolio selection (useful for logout)
                const clearPortfolioSelection = React.useCallback(() => {
                    localStorage.removeItem('selectedPortfolioId');
                    setPortfolioIdState(null);
                    setCurrentPortfolioData(null);
                }, []);
                
                const contextValue = {
                    portfolioId,
                    setPortfolioId,
                    user,
                    portfolios,
                    currentPortfolioData,
                    loadingPortfolios,
                    switchPortfolio,
                    clearPortfolioSelection,
                    refreshPortfolios: loadPortfolios,
                    refreshCurrentPortfolio: loadCurrentPortfolioData
                };
                
                return e(UserContext.Provider, { value: contextValue }, children);
            }
            
            // Custom hook to use user context
            function useUserContext() {
                const context = React.useContext(UserContext);
                if (!context) {
                    throw new Error('useUserContext must be used within UserContextProvider');
                }
                return context;
            }
            
            /**
             * Portfolio Selector Component
             * Allows users to switch between portfolios with a dropdown interface
             */
            function PortfolioSelector() {
                const { useState, useEffect, useRef } = React;
                const {
                    portfolioId,
                    portfolios,
                    currentPortfolioData,
                    loadingPortfolios,
                    switchPortfolio,
                    refreshPortfolios
                } = useUserContext();
                
                const [isOpen, setIsOpen] = useState(false);
                const dropdownRef = useRef(null);
                
                // Close dropdown when clicking outside
                useEffect(() => {
                    function handleClickOutside(event) {
                        if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
                            setIsOpen(false);
                        }
                    }
                    
                    document.addEventListener('mousedown', handleClickOutside);
                    return () => {
                        document.removeEventListener('mousedown', handleClickOutside);
                    };
                }, []);
                
                // Refresh portfolios on mount
                useEffect(() => {
                    if (!portfolios || portfolios.length === 0) {
                        refreshPortfolios();
                    }
                }, []);
                
                const handlePortfolioSelect = (portfolio) => {
                    if (portfolio.id !== portfolioId) {
                        switchPortfolio(portfolio.id);
                        setIsOpen(false);
                    }
                };
                
                const formatValue = (value) => {
                    if (!value) return '$0';
                    return new Intl.NumberFormat('en-US', {
                        style: 'currency',
                        currency: 'USD',
                        minimumFractionDigits: 0,
                        maximumFractionDigits: 0
                    }).format(value);
                };
                
                const formatPerformance = (performance) => {
                    if (!performance || !performance.ytd) return null;
                    const ytd = performance.ytd;
                    const sign = ytd >= 0 ? '+' : '';
                    return `${sign}${(ytd * 100).toFixed(2)}%`;
                };
                
                // Determine current portfolio display info
                const currentDisplay = currentPortfolioData || {
                    name: portfolios?.find(p => p.id === portfolioId)?.name || 'Portfolio',
                    value: portfolios?.find(p => p.id === portfolioId)?.value || 0
                };
                
                return e('div', { className: 'portfolio-selector', ref: dropdownRef },
                    e('div', {
                        className: `portfolio-selector-trigger ${isOpen ? 'open' : ''}`,
                        onClick: () => setIsOpen(!isOpen)
                    },
                        e('div', { className: 'portfolio-info' },
                            e('div', { className: 'portfolio-name' }, currentDisplay.name),
                            e('div', { className: 'portfolio-value' }, formatValue(currentDisplay.value))
                        ),
                        e('span', { className: `portfolio-arrow ${isOpen ? 'open' : ''}` }, 'â–¼')
                    ),
                    
                    isOpen && e('div', { className: 'portfolio-dropdown' },
                        e('div', { className: 'portfolio-dropdown-header' }, 'Select Portfolio'),
                        
                        loadingPortfolios
                            ? e('div', { className: 'portfolio-loading' },
                                e('div', { className: 'spinner-small' })
                            )
                            : portfolios && portfolios.length > 0
                                ? e('div', { className: 'portfolio-list' },
                                    portfolios.map(portfolio => 
                                        e('div', {
                                            key: portfolio.id,
                                            className: `portfolio-item ${portfolio.id === portfolioId ? 'active' : ''}`,
                                            onClick: () => handlePortfolioSelect(portfolio)
                                        },
                                            e('div', { className: 'portfolio-item-info' },
                                                e('div', { className: 'portfolio-item-name' }, portfolio.name),
                                                e('div', { className: 'portfolio-item-value' }, 
                                                    formatValue(portfolio.value || portfolio.total_value)
                                                )
                                            ),
                                            portfolio.performance && formatPerformance(portfolio.performance) &&
                                                e('div', {
                                                    className: `portfolio-item-performance ${
                                                        portfolio.performance.ytd >= 0 ? 'positive' : 'negative'
                                                    }`
                                                }, formatPerformance(portfolio.performance)),
                                            portfolio.id === portfolioId && 
                                                e('span', { className: 'portfolio-item-check' }, 'âœ“')
                                        )
                                    )
                                )
                                : e('div', { className: 'portfolio-empty' }, 
                                    'No portfolios available'
                                )
                    )
                );
            }
            
            // Pattern Registry with metadata for all 13 patterns
            const patternRegistry = {
                portfolio_overview: {
                    category: 'portfolio',
                    name: 'Portfolio Overview',
                    description: 'Comprehensive portfolio snapshot',
                    icon: 'ðŸ“Š',
                    display: {
                        panels: [
                            {
                                id: 'performance_strip',
                                title: 'Performance Metrics',
                                type: 'metrics_grid',
                                dataPath: 'perf_metrics',
                                config: {
                                    columns: 5,
                                    metrics: [
                                        { key: 'twr_1y', label: 'TWR (1Y)', format: 'percentage' },
                                        { key: 'twr_ytd', label: 'YTD Return', format: 'percentage' },
                                        { key: 'mwr_1y', label: 'MWR (1Y)', format: 'percentage' },
                                        { key: 'volatility', label: 'Volatility', format: 'percentage' },
                                        { key: 'sharpe_ratio', label: 'Sharpe Ratio', format: 'number' },
                                        { key: 'max_drawdown', label: 'Max Drawdown', format: 'percentage' },
                                        { key: 'twr_1d', label: '1 Day', format: 'percentage' },
                                        { key: 'twr_mtd', label: 'MTD', format: 'percentage' },
                                        { key: 'current_drawdown', label: 'Current DD', format: 'percentage' },
                                        { key: 'sortino_ratio', label: 'Sortino Ratio', format: 'number' }
                                    ]
                                }
                            },
                            {
                                id: 'nav_chart',
                                title: 'Portfolio Value Over Time',
                                type: 'line_chart',
                                dataPath: 'historical_nav'
                            },
                            {
                                id: 'currency_attr',
                                title: 'Currency Attribution',
                                type: 'donut_chart',
                                dataPath: 'currency_attr'
                            },
                            {
                                id: 'sector_alloc',
                                title: 'Sector Allocation',
                                type: 'pie_chart',
                                dataPath: 'sector_allocation'
                            },
                            {
                                id: 'holdings_table',
                                title: 'Holdings',
                                type: 'table',
                                dataPath: 'valued_positions.positions',
                                config: {
                                    columns: [
                                        { field: 'symbol', header: 'Symbol', format: 'text' },
                                        { field: 'quantity', header: 'Shares', format: 'number' },
                                        { field: 'market_value', header: 'Market Value', format: 'currency' },
                                        { field: 'cost_basis', header: 'Cost Basis', format: 'currency' },
                                        { field: 'price', header: 'Price', format: 'currency' },
                                        { field: 'weight', header: 'Weight (%)', format: 'percentage' },
                                        { field: 'currency', header: 'Currency', format: 'text' }
                                    ],
                                    maxRows: 50
                                }
                            }
                        ]
                    }
                },
                
                portfolio_scenario_analysis: {
                    category: 'risk',
                    name: 'Scenario Analysis',
                    description: 'Stress test portfolio with macro scenarios',
                    icon: 'âš¡',
                    display: {
                        panels: [
                            {
                                id: 'scenario_impact',
                                title: 'Scenario Impact',
                                type: 'metrics_grid',
                                dataPath: 'scenario_result'
                            },
                            {
                                id: 'position_deltas',
                                title: 'Position Deltas',
                                type: 'table',
                                dataPath: 'scenario_result.position_deltas'
                            },
                            {
                                id: 'winners_losers',
                                title: 'Winners & Losers',
                                type: 'dual_list',
                                dataPath: 'scenario_result'
                            },
                            {
                                id: 'hedge_cards',
                                title: 'Hedge Suggestions',
                                type: 'action_cards',
                                dataPath: 'hedge_suggestions.suggestions'
                            }
                        ]
                    }
                },
                
                portfolio_cycle_risk: {
                    category: 'risk',
                    name: 'Cycle Risk Analysis',
                    description: 'Analyze portfolio risk across economic cycles',
                    icon: 'ðŸ”„',
                    display: {
                        panels: [
                            {
                                id: 'cycle_risk_summary',
                                title: 'Cycle Risk Summary',
                                type: 'metrics_grid',
                                dataPath: 'cycle_risk_map'
                            },
                            {
                                id: 'vulnerabilities',
                                title: 'Vulnerabilities',
                                type: 'table',
                                dataPath: 'cycle_risk_map.amplified_factors'
                            }
                        ]
                    }
                },
                
                macro_cycles_overview: {
                    category: 'macro',
                    name: 'Macro Cycles Overview',
                    description: 'Dalio framework: Debt, Empire, Civil cycles',
                    icon: 'ðŸŒ',
                    display: {
                        panels: [
                            {
                                id: 'stdc_panel',
                                title: 'Short-Term Debt Cycle',
                                type: 'cycle_card',
                                dataPath: 'stdc'
                            },
                            {
                                id: 'ltdc_panel',
                                title: 'Long-Term Debt Cycle',
                                type: 'cycle_card',
                                dataPath: 'ltdc'
                            },
                            {
                                id: 'empire_panel',
                                title: 'Empire Cycle',
                                type: 'cycle_card',
                                dataPath: 'empire'
                            },
                            {
                                id: 'civil_panel',
                                title: 'Civil/Internal Order Cycle',
                                type: 'cycle_card',
                                dataPath: 'civil'
                            }
                        ]
                    }
                },
                
                macro_trend_monitor: {
                    category: 'macro',
                    name: 'Macro Trend Monitor',
                    description: 'Track key economic indicators and trends with alert suggestions',
                    icon: 'ðŸ“ˆ',
                    display: {
                        panels: [
                            {
                                id: 'trends_grid',
                                title: 'Economic Trends',
                                type: 'metrics_grid',
                                dataPath: 'trend_analysis'
                            },
                            {
                                id: 'indicators_chart',
                                title: 'Key Indicators',
                                type: 'line_chart',
                                dataPath: 'factor_history'
                            },
                            {
                                id: 'alert_suggestions',
                                title: 'Suggested Alerts',
                                type: 'action_cards',
                                dataPath: 'alert_suggestions.suggestions'
                            }
                        ]
                    }
                },
                
                buffett_checklist: {
                    category: 'analysis',
                    name: 'Buffett Quality Checklist',
                    description: 'Buffett-style quality and moat scorecard',
                    icon: 'âœ…',
                    display: {
                        panels: [
                            {
                                id: 'quality_score',
                                title: 'Quality Scorecard',
                                type: 'scorecard',
                                dataPath: 'moat_strength'
                            },
                            {
                                id: 'moat_analysis',
                                title: 'Moat Strength',
                                type: 'scorecard',
                                dataPath: 'moat_strength'
                            },
                            {
                                id: 'dividend_safety',
                                title: 'Dividend Safety',
                                type: 'scorecard',
                                dataPath: 'dividend_safety'
                            },
                            {
                                id: 'resilience',
                                title: 'Balance Sheet Resilience',
                                type: 'metrics_grid',
                                dataPath: 'resilience'
                            }
                        ]
                    }
                },
                
                news_impact_analysis: {
                    category: 'analysis',
                    name: 'News Impact Analysis',
                    description: 'Analyze news impact on portfolio with optional alerting',
                    icon: 'ðŸ“°',
                    display: {
                        panels: [
                            {
                                id: 'news_summary',
                                title: 'Impact Summary',
                                type: 'metrics_grid',
                                dataPath: 'impact_analysis',
                                config: {
                                    metrics: [
                                        { key: 'total_items', label: 'News Analyzed', format: 'integer' },
                                        { key: 'high_impact_count', label: 'High Impact', format: 'integer' },
                                        { key: 'exposed_portfolio_pct', label: 'Portfolio Exposure', format: 'percentage' },
                                        { key: 'overall_sentiment', label: 'Overall Sentiment', format: 'sentiment' }
                                    ],
                                    columns: 4
                                }
                            },
                            {
                                id: 'news_items',
                                title: 'Relevant News',
                                type: 'news_list',
                                dataPath: 'impact_analysis.news_with_impact'
                            },
                            {
                                id: 'entity_mentions',
                                title: 'Entity Mentions',
                                type: 'bar_chart',
                                dataPath: 'impact_analysis.entity_mentions'
                            },
                            {
                                id: 'alert_result',
                                title: 'Alert Status',
                                type: 'metrics_grid',
                                dataPath: 'alert_result',
                                config: {
                                    metrics: [
                                        { key: 'status', label: 'Alert Status', format: 'text' },
                                        { key: 'alert_id', label: 'Alert ID', format: 'text' },
                                        { key: 'created_at', label: 'Created At', format: 'datetime' }
                                    ],
                                    columns: 3
                                }
                            }
                        ]
                    }
                },
                
                holding_deep_dive: {
                    category: 'portfolio',
                    name: 'Holding Deep Dive',
                    description: 'Detailed analysis of individual holdings',
                    icon: 'ðŸ”',
                    display: {
                        panels: [
                            {
                                id: 'holding_metrics',
                                title: 'Holding Metrics',
                                type: 'metrics_grid',
                                dataPath: 'position'
                            },
                            {
                                id: 'fundamentals',
                                title: 'Fundamentals',
                                type: 'table',
                                dataPath: 'fundamentals'
                            }
                        ]
                    }
                },
                
                policy_rebalance: {
                    category: 'action',
                    name: 'Policy Rebalance',
                    description: 'Generate rebalancing recommendations',
                    icon: 'âš–ï¸',
                    display: {
                        panels: [
                            {
                                id: 'rebalance_summary',
                                title: 'Rebalance Summary',
                                type: 'metrics_grid',
                                dataPath: 'rebalance_result'
                            },
                            {
                                id: 'trade_proposals',
                                title: 'Trade Proposals',
                                type: 'table',
                                dataPath: 'rebalance_result.trades'
                            }
                        ]
                    }
                },
                
                cycle_deleveraging_scenarios: {
                    category: 'action',
                    name: 'Cycle Deleveraging Scenarios',
                    description: 'Deleveraging strategies based on cycles',
                    icon: 'ðŸ“‰',
                    display: {
                        panels: [
                            {
                                id: 'deleveraging_options',
                                title: 'Deleveraging Options',
                                type: 'action_cards',
                                dataPath: 'options'
                            },
                            {
                                id: 'impact_analysis',
                                title: 'Impact Analysis',
                                type: 'table',
                                dataPath: 'impact'
                            }
                        ]
                    }
                },
                
                export_portfolio_report: {
                    category: 'reports',
                    name: 'Export Portfolio Report',
                    description: 'Generate comprehensive portfolio PDF report',
                    icon: 'ðŸ“„',
                    display: {
                        panels: [
                            {
                                id: 'report_status',
                                title: 'Export Status',
                                type: 'metrics_grid',
                                dataPath: 'pdf_result',
                                config: {
                                    metrics: [
                                        { key: 'status', label: 'Status', format: 'text' },
                                        { key: 'file_size', label: 'File Size', format: 'bytes' },
                                        { key: 'download_url', label: 'Download URL', format: 'url' },
                                        { key: 'generated_at', label: 'Generated At', format: 'datetime' }
                                    ],
                                    columns: 4
                                }
                            },
                            {
                                id: 'report_preview',
                                title: 'Report Preview',
                                type: 'report_viewer',
                                dataPath: 'pdf_result.download_url'
                            }
                        ]
                    }
                },
                
                corporate_actions_upcoming: {
                    category: 'corporate_actions',
                    name: 'Upcoming Corporate Actions',
                    description: 'Track dividends, splits, and earnings for portfolio holdings',
                    icon: 'ðŸ“…',
                    display: {
                        panels: [
                            {
                                id: 'actions_table',
                                title: 'Upcoming Corporate Actions',
                                type: 'table',
                                dataPath: 'actions_with_impact.actions',
                                config: {
                                    columns: [
                                        { field: 'date', header: 'Date', width: 120 },
                                        { field: 'symbol', header: 'Symbol', width: 100 },
                                        { field: 'type', header: 'Type', width: 100 },
                                        { field: 'amount', header: 'Amount', format: 'currency', width: 120 },
                                        { field: 'portfolio_quantity', header: 'Shares', format: 'number', width: 100 },
                                        { field: 'portfolio_impact', header: 'Impact', format: 'currency', width: 120 }
                                    ],
                                    sort_by: 'date',
                                    sort_order: 'asc'
                                }
                            },
                            {
                                id: 'summary_metrics',
                                title: 'Summary',
                                type: 'metrics_grid',
                                dataPath: 'actions_with_impact.summary',
                                config: {
                                    columns: 4,
                                    metrics: [
                                        { key: 'total_actions', label: 'Total Actions', format: 'number' },
                                        { key: 'dividends_expected', label: 'Dividends Expected', format: 'currency' },
                                        { key: 'splits_pending', label: 'Splits Pending', format: 'number' },
                                        { key: 'earnings_releases', label: 'Earnings Releases', format: 'number' }
                                    ]
                                }
                            },
                            {
                                id: 'notifications_list',
                                title: 'Notifications',
                                type: 'dual_list',
                                dataPath: 'actions_with_impact.notifications',
                                config: {
                                    urgent_title: 'Urgent (Next 7 Days)',
                                    informational_title: 'Upcoming'
                                }
                            }
                        ]
                    }
                },
                
                portfolio_macro_overview: {
                    category: 'reports',
                    name: 'Portfolio Macro Overview',
                    description: 'Portfolio analysis with macro context',
                    icon: 'ðŸŒ',
                    display: {
                        panels: [
                            {
                                id: 'macro_context',
                                title: 'Macro Context',
                                type: 'metrics_grid',
                                dataPath: 'macro_context'
                            },
                            {
                                id: 'portfolio_positioning',
                                title: 'Portfolio Positioning',
                                type: 'table',
                                dataPath: 'positioning'
                            }
                        ]
                    }
                }
            };
            
            // Pattern categories for navigation
            const patternCategories = {
                portfolio: {
                    name: 'Portfolio',
                    patterns: ['portfolio_overview', 'holding_deep_dive']
                },
                risk: {
                    name: 'Risk Analysis',
                    patterns: ['portfolio_scenario_analysis', 'portfolio_cycle_risk']
                },
                macro: {
                    name: 'Macro Analysis',
                    patterns: ['macro_cycles_overview', 'macro_trend_monitor']
                },
                analysis: {
                    name: 'Deep Analysis',
                    patterns: ['buffett_checklist', 'news_impact_analysis']
                },
                action: {
                    name: 'Actions',
                    patterns: ['policy_rebalance', 'cycle_deleveraging_scenarios']
                },
                reports: {
                    name: 'Reports',
                    patterns: ['export_portfolio_report', 'portfolio_macro_overview']
                }
            };
            
            /**
             * Helper function to extract data from nested path
             */
            function getDataByPath(data, path) {
                if (!path || !data) return data;
                
                const parts = path.split('.');
                let current = data;
                
                for (const part of parts) {
                    if (current && typeof current === 'object') {
                        current = current[part];
                    } else {
                        return null;
                    }
                }
                
                return current;
            }
            
            /**
             * Generic Pattern Renderer Component
             */
            function PatternRenderer({ pattern, inputs = {}, config = {}, onDataLoaded }) {
                const [loading, setLoading] = useState(true);
                const [error, setError] = useState(null);
                const [data, setData] = useState(null);
                const [panels, setPanels] = useState([]);
                const [provenanceWarnings, setProvenanceWarnings] = useState([]);
                const { portfolioId } = useUserContext();
                
                useEffect(() => {
                    loadPattern();
                }, [pattern, portfolioId, JSON.stringify(inputs)]);
                
                // Listen for portfolio changes from the portfolio selector
                useEffect(() => {
                    const handlePortfolioChange = (event) => {
                        console.log('Portfolio changed, reloading pattern:', pattern);
                        loadPattern();
                    };
                    
                    window.addEventListener('portfolioChanged', handlePortfolioChange);
                    
                    return () => {
                        window.removeEventListener('portfolioChanged', handlePortfolioChange);
                    };
                }, [pattern, inputs]);
                
                const loadPattern = async () => {
                    try {
                        setLoading(true);
                        setError(null);
                        
                        // Don't block execution - let backend handle authentication
                        // Backend will return appropriate error if authentication required
                        const token = TokenManager.getToken();
                        if (!token) {
                            console.warn(`No authentication token for pattern ${pattern}`);
                            // Don't block - let backend handle auth
                            // Some patterns might not require auth
                        }
                        
                        // Patterns that don't require portfolio_id
                        const nonPortfolioPatterns = ['macro_cycles_overview', 'macro_trend_monitor'];
                        const needsPortfolioId = !nonPortfolioPatterns.includes(pattern);
                        
                        // Build final inputs - only add portfolio_id if pattern needs it
                        const finalInputs = { ...inputs };
                        
                        if (needsPortfolioId) {
                            // Ensure we always have a valid portfolio ID for portfolio patterns
                            let validPortfolioId = portfolioId || inputs.portfolio_id;
                            
                            // If still no portfolio ID, use the fallback
                            if (!validPortfolioId) {
                                validPortfolioId = getCurrentPortfolioId();
                                console.warn('No portfolio ID in context or inputs, using fallback:', validPortfolioId);
                            }
                            
                            // Add portfolio ID to inputs, ensuring it's always present
                            finalInputs.portfolio_id = validPortfolioId;
                        }
                        
                        console.log(`Executing pattern ${pattern} with inputs:`, finalInputs);
                        
                        // Execute pattern
                        const result = await apiClient.executePattern(pattern, finalInputs);
                        
                        console.log(`Pattern ${pattern} execution result:`, result);
                        
                        // Get pattern metadata
                        const metadata = patternRegistry[pattern];
                        if (!metadata) {
                            throw new Error(`Pattern ${pattern} not found in registry`);
                        }
                        
                        // PHASE 1 FIX: Check for provenance warnings in data
                        const dataResult = result.data || result;
                        const provenanceWarnings = [];
                        
                        // Recursively check for _provenance fields in data
                        function checkProvenance(obj, path = '') {
                            if (!obj || typeof obj !== 'object') return;
                            
                            if (obj._provenance && obj._provenance.type === 'stub') {
                                provenanceWarnings.push({
                                    path: path || 'root',
                                    warnings: obj._provenance.warnings || [],
                                    recommendation: obj._provenance.recommendation || 'Do not use for investment decisions'
                                });
                            }
                            
                            // Recursively check nested objects
                            for (const key in obj) {
                                if (key !== '_provenance' && obj.hasOwnProperty(key)) {
                                    checkProvenance(obj[key], path ? `${path}.${key}` : key);
                                }
                            }
                        }
                        
                        checkProvenance(dataResult);
                        
                        // Set data and panels
                        setData(dataResult);
                        setPanels(metadata.display.panels || []);
                        setProvenanceWarnings(provenanceWarnings);
                        setLoading(false);
                        
                        // Display warnings if found
                        if (provenanceWarnings.length > 0) {
                            console.warn('Provenance warnings detected:', provenanceWarnings);
                        }
                        
                        // Callback for parent components
                        if (onDataLoaded) {
                            onDataLoaded(dataResult);
                        }
                    } catch (err) {
                        console.error(`Error loading pattern ${pattern}:`, err);
                        const errorMessage = err.message || 'Failed to load pattern';
                        setError(errorMessage);
                        setLoading(false);
                        // Call onDataLoaded with error data if callback exists
                        if (onDataLoaded) {
                            onDataLoaded({ error: errorMessage });
                        }
                    }
                };
                
                // If hidden (via config.hidden), return null to avoid blocking
                // The parent component will handle loading/error states
                const isHidden = config.hidden || (config.showPanels && config.showPanels.length === 0);
                
                if (loading && !isHidden) {
                    return e('div', { className: 'loading-container' },
                        e('div', { className: 'loading-spinner' }),
                        e('p', null, `Loading ${patternRegistry[pattern]?.name || pattern.replace(/_/g, ' ')}...`)
                    );
                }
                
                if (error && !isHidden) {
                    // Provide more helpful error messages based on pattern type
                    let errorMessage = String(error);
                    let helpfulTip = '';
                    
                    if (pattern.includes('corporate_actions')) {
                        if (errorMessage.includes('FMP') || errorMessage.includes('API')) {
                            helpfulTip = 'The corporate actions data provider may be temporarily unavailable. Please try again in a few moments.';
                        } else if (errorMessage.includes('portfolio')) {
                            helpfulTip = 'Please ensure you have selected a valid portfolio with holdings.';
                        } else {
                            helpfulTip = 'Corporate actions data is fetched from external providers. If your portfolio has no holdings, no actions will be shown.';
                        }
                    } else if (errorMessage.includes('401') || errorMessage.includes('authentication')) {
                        helpfulTip = 'Your session may have expired. Please refresh the page and log in again.';
                    } else if (errorMessage.includes('404')) {
                        helpfulTip = 'The requested data could not be found. Please verify your portfolio selection.';
                    }
                    
                    return e('div', { className: 'error-container' },
                        e('h3', null, 'âš ï¸ Unable to Load Data'),
                        e('p', { style: { marginBottom: '1rem' } }, errorMessage),
                        helpfulTip && e('p', { style: { fontSize: '0.9rem', opacity: 0.8 } }, `ðŸ’¡ ${helpfulTip}`),
                        e('button', { 
                            className: 'btn btn-primary',
                            onClick: loadPattern,
                            style: { marginTop: '1rem' }
                        }, 'ðŸ”„ Retry')
                    );
                }
                
                // If hidden, return null to avoid rendering anything
                if (isHidden) {
                    return null;
                }
                
                // Filter panels if config.showPanels is provided
                const filteredPanels = config.showPanels 
                    ? panels.filter(panel => config.showPanels.includes(panel.id))
                    : panels;
                
                return e('div', { className: 'pattern-content' },
                    // PHASE 1 FIX: Display provenance warnings
                    e(ProvenanceWarningBanner, { warnings: provenanceWarnings }),
                    filteredPanels.map(panel => 
                        e(PanelRenderer, {
                            key: panel.id,
                            panel: panel,
                            data: getDataByPath(data, panel.dataPath),
                            fullData: data
                        })
                    )
                );
            }
            
            /**
             * Generic Panel Renderer that delegates to specific panel types
             */
            function PanelRenderer({ panel, data, fullData }) {
                const { type, title, config } = panel;
                
                // Render based on panel type
                switch (type) {
                    case 'metrics_grid':
                        return e(MetricsGridPanel, { title, data, config });
                    case 'table':
                        return e(TablePanel, { title, data, config });
                    case 'line_chart':
                        return e(LineChartPanel, { title, data, config });
                    case 'pie_chart':
                        return e(PieChartPanel, { title, data, config });
                    case 'donut_chart':
                        return e(DonutChartPanel, { title, data, config });
                    case 'bar_chart':
                        return e(BarChartPanel, { title, data, config });
                    case 'action_cards':
                        return e(ActionCardsPanel, { title, data, config });
                    case 'cycle_card':
                        return e(CycleCardPanel, { title, data, config });
                    case 'scorecard':
                        return e(ScorecardPanel, { title, data, config });
                    case 'dual_list':
                        return e(DualListPanel, { title, data, config });
                    case 'news_list':
                        return e(NewsListPanel, { title, data, config });
                    case 'report_viewer':
                        return e(ReportViewerPanel, { title, data, config });
                    default:
                        return e('div', { className: 'card' },
                            e('div', { className: 'card-header' },
                                e('h3', { className: 'card-title' }, title || 'Panel')
                            ),
                            e('p', null, `Unsupported panel type: ${type}`)
                        );
                }
            }
            // ----- OPTIMIZATION LOGIC -----
            
            /**
             * Generate trade proposals based on portfolio optimization
             * @param {object} portfolio - Current portfolio
             * @param {object} targetAllocation - Target allocation
             * @param {object} constraints - Trading constraints
             * @returns {Array} Trade proposals
             */
            const generateTradeProposals = (portfolio, targetAllocation, constraints = {}) => {
                const proposals = [];
                const currentHoldings = portfolio.holdings || [];
                const totalValue = portfolio.value || 0;
                const maxTrades = constraints.maxTrades || 10;
                const minTradeSize = constraints.minTradeSize || 1000;
                const maxPositionSize = constraints.maxPositionSize || 0.15;
                
                // Calculate current allocations
                const currentAllocations = {};
                currentHoldings.forEach(holding => {
                    const allocation = holding.value / totalValue;
                    currentAllocations[holding.symbol] = allocation;
                });
                
                // Identify required trades
                Object.keys(targetAllocation).forEach(symbol => {
                    const current = currentAllocations[symbol] || 0;
                    const target = targetAllocation[symbol];
                    const difference = target - current;
                    const dollarDifference = difference * totalValue;
                    
                    if (Math.abs(dollarDifference) > minTradeSize) {
                        const holding = currentHoldings.find(h => h.symbol === symbol) || {};
                        const price = holding.price || 100;
                        const shares = Math.round(dollarDifference / price);
                        
                        proposals.push({
                            id: proposals.length + 1,
                            action: dollarDifference > 0 ? 'BUY' : 'SELL',
                            symbol,
                            shares: Math.abs(shares),
                            price,
                            value: Math.abs(dollarDifference),
                            currentAllocation: current * 100,
                            targetAllocation: target * 100,
                            impact: (difference * 100).toFixed(2) + '%',
                            reason: generateTradeReason(current, target, symbol),
                            confidence: calculateTradeConfidence(difference, symbol),
                            priority: Math.abs(difference) // Higher difference = higher priority
                        });
                    }
                });
                
                // Sort by priority and limit to maxTrades
                return proposals
                    .sort((a, b) => b.priority - a.priority)
                    .slice(0, maxTrades)
                    .map((trade, index) => ({ ...trade, id: index + 1 }));
            };
            
            /**
             * Helper function to generate trade reason
             */
            const generateTradeReason = (current, target, symbol) => {
                const diff = target - current;
                if (diff > 0.05) return `Increase ${symbol} exposure to target`;
                if (diff < -0.05) return `Reduce ${symbol} concentration`;
                if (diff > 0) return `Rebalance ${symbol} to target weight`;
                return `Trim ${symbol} position`;
            };
            
            /**
             * Helper function to calculate trade confidence
             */
            const calculateTradeConfidence = (difference, symbol) => {
                const baseConfidence = 70;
                const differenceBonus = Math.min(Math.abs(difference) * 100, 20);
                const volatilityPenalty = Math.random() * 10; // Placeholder for actual volatility
                return Math.min(95, Math.max(50, baseConfidence + differenceBonus - volatilityPenalty));
            };
            
            /**
             * Analyze trade impact on portfolio metrics
             * @param {Array} trades - Proposed trades
             * @param {object} portfolio - Current portfolio
             * @param {object} marketData - Market data for calculations
             * @returns {object} Impact analysis results
             */
            const analyzeTradeImpact = (trades, portfolio, marketData = {}) => {
                const currentMetrics = portfolio.metrics || {};
                const currentReturn = currentMetrics.expectedReturn || 8;
                const currentVolatility = currentMetrics.volatility || 15;
                const currentSharpe = currentMetrics.sharpe || 0.85;
                const currentBeta = currentMetrics.beta || 1.0;
                
                // Simulate post-trade metrics
                let portfolioAfterTrades = { ...portfolio };
                let totalBuyValue = 0;
                let totalSellValue = 0;
                
                trades.forEach(trade => {
                    if (trade.action === 'BUY') {
                        totalBuyValue += trade.value || (trade.shares * trade.price);
                    } else {
                        totalSellValue += trade.value || (trade.shares * trade.price);
                    }
                });
                
                // Calculate expected changes (simplified model)
                const netChange = totalBuyValue - totalSellValue;
                const rebalancingEffect = Math.abs(netChange) / portfolio.value;
                
                // Estimate new metrics
                const returnImprovement = rebalancingEffect * 0.15; // 15% improvement per 1% rebalanced
                const volatilityReduction = rebalancingEffect * 0.2; // 20% reduction per 1% rebalanced
                const betaChange = netChange > 0 ? 0.05 : -0.05; // Directional beta change
                
                const optimizedReturn = currentReturn * (1 + returnImprovement);
                const optimizedVolatility = currentVolatility * (1 - volatilityReduction);
                const optimizedSharpe = calculateSharpeRatio(optimizedReturn / 100, 0.02, optimizedVolatility / 100);
                const optimizedBeta = currentBeta + betaChange;
                
                // Calculate improvement metrics
                const metrics = [
                    {
                        metric: 'Expected Return',
                        current: currentReturn,
                        optimized: optimizedReturn,
                        change: ((optimizedReturn - currentReturn) / currentReturn) * 100,
                        improvement: optimizedReturn > currentReturn
                    },
                    {
                        metric: 'Volatility',
                        current: currentVolatility,
                        optimized: optimizedVolatility,
                        change: ((optimizedVolatility - currentVolatility) / currentVolatility) * 100,
                        improvement: optimizedVolatility < currentVolatility
                    },
                    {
                        metric: 'Sharpe Ratio',
                        current: currentSharpe,
                        optimized: optimizedSharpe,
                        change: optimizedSharpe - currentSharpe,
                        improvement: optimizedSharpe > currentSharpe
                    },
                    {
                        metric: 'Beta',
                        current: currentBeta,
                        optimized: optimizedBeta,
                        change: optimizedBeta - currentBeta,
                        improvement: Math.abs(optimizedBeta - 1) < Math.abs(currentBeta - 1)
                    }
                ];
                
                // Calculate overall improvement score
                const improvementScore = metrics.reduce((score, m) => 
                    score + (m.improvement ? 1 : 0), 0) / metrics.length;
                
                return {
                    metrics,
                    totalBuyValue,
                    totalSellValue,
                    netChange,
                    rebalancingPercentage: rebalancingEffect * 100,
                    improvementScore,
                    recommendation: improvementScore > 0.5 ? 'Execute trades' : 'Review trades',
                    estimatedCost: trades.reduce((sum, t) => sum + (t.shares * t.price * 0.001), 0), // 0.1% transaction cost
                    riskReduction: volatilityReduction * 100,
                    returnEnhancement: returnImprovement * 100
                };
            };
            
            /**
             * Calculate efficient frontier points for portfolio optimization
             * @param {Array} assets - Array of assets with returns and risks
             * @param {object} constraints - Optimization constraints
             * @returns {Array} Efficient frontier points
             */
            const calculateEfficientFrontier = (assets, constraints = {}) => {
                const minRisk = constraints.minRisk || 5;
                const maxRisk = constraints.maxRisk || 25;
                const riskStep = constraints.riskStep || 1;
                const riskFreeRate = constraints.riskFreeRate || 0.02;
                
                const frontierPoints = [];
                
                for (let risk = minRisk; risk <= maxRisk; risk += riskStep) {
                    // Simplified efficient frontier calculation
                    // In reality, this would use mean-variance optimization
                    const baseReturn = 4;
                    const riskPremium = 0.4;
                    const diminishingFactor = Math.log10(risk / 5);
                    
                    // Calculate return for this risk level
                    const expectedReturn = baseReturn + (risk * riskPremium * diminishingFactor);
                    
                    // Add some randomness to simulate real portfolio variations
                    const variation = (Math.random() - 0.5) * 2;
                    const adjustedReturn = expectedReturn + variation;
                    
                    // Calculate Sharpe ratio for this point
                    const sharpe = (adjustedReturn - riskFreeRate * 100) / risk;
                    
                    frontierPoints.push({
                        risk,
                        return: adjustedReturn,
                        sharpe,
                        isEfficient: sharpe > 0.3,
                        allocation: generateOptimalAllocation(risk)
                    });
                }
                
                return frontierPoints;
            };
            
            /**
             * Helper to generate optimal allocation for a given risk level
             */
            const generateOptimalAllocation = (riskLevel) => {
                const conservativeRatio = Math.max(0, (25 - riskLevel) / 20);
                const aggressiveRatio = Math.min(1, riskLevel / 25);
                
                return {
                    stocks: aggressiveRatio * 70,
                    bonds: conservativeRatio * 40,
                    alternatives: 10 + (riskLevel / 25) * 10,
                    cash: Math.max(5, 20 - riskLevel)
                };
            };
            
            /**
             * Optimize portfolio for risk/return characteristics
             * @param {object} portfolio - Current portfolio
             * @param {object} objectives - Optimization objectives
             * @param {object} constraints - Optimization constraints
             * @returns {object} Optimization results
             */
            const optimizeRiskReturn = (portfolio, objectives = {}, constraints = {}) => {
                const targetReturn = objectives.targetReturn || 10;
                const maxRisk = objectives.maxRisk || 20;
                const riskTolerance = objectives.riskTolerance || 'moderate';
                
                // Current portfolio metrics
                const currentMetrics = {
                    return: portfolio.metrics?.expectedReturn || 8,
                    risk: portfolio.metrics?.volatility || 15,
                    sharpe: portfolio.metrics?.sharpe || 0.85,
                    diversification: portfolio.metrics?.diversification || 0.7
                };
                
                // Define optimal targets based on risk tolerance
                let optimalTargets = {};
                switch (riskTolerance) {
                    case 'conservative':
                        optimalTargets = {
                            return: 6,
                            risk: 10,
                            stockAllocation: 40,
                            bondAllocation: 50,
                            alternativeAllocation: 10
                        };
                        break;
                    case 'aggressive':
                        optimalTargets = {
                            return: 12,
                            risk: 20,
                            stockAllocation: 80,
                            bondAllocation: 10,
                            alternativeAllocation: 10
                        };
                        break;
                    default: // moderate
                        optimalTargets = {
                            return: 9,
                            risk: 15,
                            stockAllocation: 60,
                            bondAllocation: 30,
                            alternativeAllocation: 10
                        };
                }
                
                // Calculate optimization actions needed
                const actions = [];
                
                if (currentMetrics.risk > optimalTargets.risk) {
                    actions.push({
                        type: 'REDUCE_RISK',
                        description: 'Reduce portfolio volatility',
                        target: optimalTargets.risk,
                        current: currentMetrics.risk,
                        priority: 'HIGH'
                    });
                }
                
                if (currentMetrics.return < optimalTargets.return * 0.9) {
                    actions.push({
                        type: 'INCREASE_RETURN',
                        description: 'Enhance expected returns',
                        target: optimalTargets.return,
                        current: currentMetrics.return,
                        priority: 'MEDIUM'
                    });
                }
                
                if (currentMetrics.sharpe < 1.0) {
                    actions.push({
                        type: 'IMPROVE_EFFICIENCY',
                        description: 'Improve risk-adjusted returns',
                        target: 1.0,
                        current: currentMetrics.sharpe,
                        priority: 'HIGH'
                    });
                }
                
                // Generate rebalancing recommendations
                const rebalancingNeeded = Math.abs(currentMetrics.return - optimalTargets.return) > 1 ||
                                         Math.abs(currentMetrics.risk - optimalTargets.risk) > 2;
                
                return {
                    currentMetrics,
                    optimalTargets,
                    actions,
                    rebalancingNeeded,
                    optimizationScore: calculateOptimizationScore(currentMetrics, optimalTargets),
                    recommendations: generateOptimizationRecommendations(actions),
                    estimatedImprovement: {
                        return: optimalTargets.return - currentMetrics.return,
                        risk: currentMetrics.risk - optimalTargets.risk,
                        sharpe: (optimalTargets.return - 2) / optimalTargets.risk - currentMetrics.sharpe
                    }
                };
            };
            
            /**
             * Helper to calculate optimization score
             */
            const calculateOptimizationScore = (current, target) => {
                const returnScore = Math.min(current.return / target.return, 1);
                const riskScore = Math.min(target.risk / current.risk, 1);
                const sharpeScore = Math.min(current.sharpe / 1.0, 1);
                return (returnScore + riskScore + sharpeScore) / 3 * 10;
            };
            
            /**
             * Helper to generate optimization recommendations
             */
            const generateOptimizationRecommendations = (actions) => {
                const recommendations = [];
                actions.forEach(action => {
                    switch (action.type) {
                        case 'REDUCE_RISK':
                            recommendations.push('Increase allocation to bonds and defensive assets');
                            recommendations.push('Consider adding low-correlation alternatives');
                            break;
                        case 'INCREASE_RETURN':
                            recommendations.push('Increase exposure to growth assets');
                            recommendations.push('Consider sector rotation to high-momentum areas');
                            break;
                        case 'IMPROVE_EFFICIENCY':
                            recommendations.push('Rebalance to optimal asset allocation');
                            recommendations.push('Reduce concentration in underperforming positions');
                            break;
                    }
                });
                return recommendations;
            };
            
            // ----- ATTRIBUTION ANALYSIS LOGIC -----
            
            /**
             * Calculate currency attribution for multi-currency portfolios
             * @param {Array} positions - Portfolio positions with currency exposure
             * @param {object} fxRates - Foreign exchange rates
             * @param {string} baseCurrency - Base currency for reporting
             * @returns {object} Currency attribution analysis
             */
            const calculateCurrencyAttribution = (positions, fxRates, baseCurrency = 'USD') => {
                const attribution = {
                    localReturns: {},
                    fxImpact: {},
                    crossEffects: {},
                    totalAttribution: 0
                };
                
                positions.forEach(position => {
                    const currency = position.currency || baseCurrency;
                    const localReturn = position.localReturn || 0;
                    const fxReturn = fxRates[currency]?.change || 0;
                    
                    // Local return contribution
                    const localContribution = position.weight * localReturn;
                    
                    // FX impact contribution
                    const fxContribution = position.weight * fxReturn;
                    
                    // Cross effect (interaction between local and FX)
                    const crossEffect = position.weight * localReturn * fxReturn;
                    
                    // Aggregate by currency
                    if (!attribution.localReturns[currency]) {
                        attribution.localReturns[currency] = 0;
                        attribution.fxImpact[currency] = 0;
                        attribution.crossEffects[currency] = 0;
                    }
                    
                    attribution.localReturns[currency] += localContribution;
                    attribution.fxImpact[currency] += fxContribution;
                    attribution.crossEffects[currency] += crossEffect;
                });
                
                // Calculate totals
                const totalLocal = Object.values(attribution.localReturns).reduce((sum, val) => sum + val, 0);
                const totalFx = Object.values(attribution.fxImpact).reduce((sum, val) => sum + val, 0);
                const totalCross = Object.values(attribution.crossEffects).reduce((sum, val) => sum + val, 0);
                
                attribution.totalAttribution = totalLocal + totalFx + totalCross;
                
                // Add summary statistics
                attribution.summary = {
                    localReturnContribution: totalLocal,
                    fxContribution: totalFx,
                    interactionEffect: totalCross,
                    totalReturn: attribution.totalAttribution,
                    fxImpactPercentage: totalFx / Math.abs(attribution.totalAttribution) * 100
                };
                
                // Identify major currency impacts
                attribution.majorImpacts = Object.keys(attribution.fxImpact)
                    .map(currency => ({
                        currency,
                        impact: attribution.fxImpact[currency],
                        percentage: attribution.fxImpact[currency] / totalFx * 100
                    }))
                    .sort((a, b) => Math.abs(b.impact) - Math.abs(a.impact))
                    .slice(0, 5);
                
                return attribution;
            };
            
            /**
             * Calculate factor attribution (selection, allocation, interaction)
             * @param {object} portfolio - Portfolio with holdings and returns
             * @param {object} benchmark - Benchmark for comparison
             * @param {Array} factors - Factors to analyze
             * @returns {object} Factor attribution results
             */
            const calculateFactorAttribution = (portfolio, benchmark, factors = []) => {
                const defaultFactors = ['selection', 'allocation', 'interaction'];
                const analysisFactors = factors.length > 0 ? factors : defaultFactors;
                
                const attribution = {
                    factors: {},
                    totalActive: 0,
                    contributions: []
                };
                
                // Calculate portfolio and benchmark returns
                const portfolioReturn = portfolio.return || 0;
                const benchmarkReturn = benchmark.return || 0;
                const activeReturn = portfolioReturn - benchmarkReturn;
                
                // Selection effect (stock picking within sectors)
                const selectionEffect = portfolio.sectors?.reduce((total, sector) => {
                    const sectorReturn = sector.return || 0;
                    const benchmarkSectorReturn = benchmark.sectors?.find(s => s.name === sector.name)?.return || 0;
                    const benchmarkWeight = benchmark.sectors?.find(s => s.name === sector.name)?.weight || 0;
                    return total + benchmarkWeight * (sectorReturn - benchmarkSectorReturn);
                }, 0) || 0;
                
                // Allocation effect (sector weighting decisions)
                const allocationEffect = portfolio.sectors?.reduce((total, sector) => {
                    const portfolioWeight = sector.weight || 0;
                    const benchmarkWeight = benchmark.sectors?.find(s => s.name === sector.name)?.weight || 0;
                    const benchmarkSectorReturn = benchmark.sectors?.find(s => s.name === sector.name)?.return || 0;
                    return total + (portfolioWeight - benchmarkWeight) * (benchmarkSectorReturn - benchmarkReturn);
                }, 0) || 0;
                
                // Interaction effect (combined selection and allocation)
                const interactionEffect = portfolio.sectors?.reduce((total, sector) => {
                    const portfolioWeight = sector.weight || 0;
                    const benchmarkWeight = benchmark.sectors?.find(s => s.name === sector.name)?.weight || 0;
                    const sectorReturn = sector.return || 0;
                    const benchmarkSectorReturn = benchmark.sectors?.find(s => s.name === sector.name)?.return || 0;
                    return total + (portfolioWeight - benchmarkWeight) * (sectorReturn - benchmarkSectorReturn);
                }, 0) || 0;
                
                // Other factors (trading costs, currency, etc.)
                const tradingEffect = portfolio.tradingCosts || 0;
                const currencyEffect = portfolio.currencyImpact || 0;
                const residual = activeReturn - (selectionEffect + allocationEffect + interactionEffect + tradingEffect + currencyEffect);
                
                // Populate attribution object
                attribution.factors = {
                    selection: selectionEffect,
                    allocation: allocationEffect,
                    interaction: interactionEffect,
                    trading: tradingEffect,
                    currency: currencyEffect,
                    residual: residual
                };
                
                attribution.totalActive = activeReturn;
                
                // Calculate contribution percentages
                Object.keys(attribution.factors).forEach(factor => {
                    const contribution = attribution.factors[factor];
                    attribution.contributions.push({
                        factor: factor.charAt(0).toUpperCase() + factor.slice(1),
                        contribution: contribution * 100,
                        percentage: activeReturn !== 0 ? (contribution / activeReturn) * 100 : 0
                    });
                });
                
                return attribution;
            };
            
            /**
             * Calculate sector performance attribution
             * @param {Array} sectors - Portfolio sectors with weights and returns
             * @param {Array} benchmarkSectors - Benchmark sectors
             * @returns {object} Sector attribution analysis
             */
            const calculateSectorAttribution = (sectors, benchmarkSectors) => {
                const attribution = [];
                const totalPortfolioReturn = sectors.reduce((sum, s) => sum + s.weight * s.return, 0);
                const totalBenchmarkReturn = benchmarkSectors.reduce((sum, s) => sum + s.weight * s.return, 0);
                
                sectors.forEach(sector => {
                    const benchmarkSector = benchmarkSectors.find(s => s.name === sector.name) || {
                        weight: 0,
                        return: totalBenchmarkReturn
                    };
                    
                    // Calculate attribution components
                    const allocationEffect = (sector.weight - benchmarkSector.weight) * 
                                            (benchmarkSector.return - totalBenchmarkReturn);
                    const selectionEffect = benchmarkSector.weight * 
                                          (sector.return - benchmarkSector.return);
                    const interactionEffect = (sector.weight - benchmarkSector.weight) * 
                                             (sector.return - benchmarkSector.return);
                    
                    const totalContribution = allocationEffect + selectionEffect + interactionEffect;
                    
                    attribution.push({
                        sector: sector.name,
                        weight: sector.weight,
                        return: sector.return,
                        benchmarkWeight: benchmarkSector.weight,
                        benchmarkReturn: benchmarkSector.return,
                        activeWeight: sector.weight - benchmarkSector.weight,
                        activeReturn: sector.return - benchmarkSector.return,
                        allocation: allocationEffect * 100,
                        selection: selectionEffect * 100,
                        interaction: interactionEffect * 100,
                        contribution: totalContribution * 100
                    });
                });
                
                // Sort by total contribution
                attribution.sort((a, b) => Math.abs(b.contribution) - Math.abs(a.contribution));
                
                return {
                    sectorDetails: attribution,
                    totalActive: (totalPortfolioReturn - totalBenchmarkReturn) * 100,
                    topContributors: attribution.slice(0, 3),
                    bottomContributors: attribution.slice(-3),
                    summary: {
                        allocationTotal: attribution.reduce((sum, s) => sum + s.allocation, 0),
                        selectionTotal: attribution.reduce((sum, s) => sum + s.selection, 0),
                        interactionTotal: attribution.reduce((sum, s) => sum + s.interaction, 0)
                    }
                };
            };
            
            /**
             * Calculate multi-period attribution (linking returns over time)
             * @param {Array} periods - Array of period data with returns
             * @param {string} method - Attribution method ('arithmetic' or 'geometric')
             * @returns {object} Multi-period attribution results
             */
            const calculateMultiPeriodAttribution = (periods, method = 'geometric') => {
                if (!periods || periods.length === 0) {
                    return {
                        totalReturn: 0,
                        annualizedReturn: 0,
                        periods: []
                    };
                }
                
                let cumulativeReturn = 1;
                const periodResults = [];
                
                periods.forEach((period, index) => {
                    const periodReturn = period.return || 0;
                    const localReturn = period.localReturn || periodReturn;
                    const currencyReturn = period.currencyReturn || 0;
                    
                    let contribution;
                    if (method === 'geometric') {
                        // Geometric linking
                        contribution = cumulativeReturn * periodReturn;
                        cumulativeReturn *= (1 + periodReturn);
                    } else {
                        // Arithmetic linking
                        contribution = periodReturn;
                        cumulativeReturn += periodReturn;
                    }
                    
                    periodResults.push({
                        period: period.name || `Period ${index + 1}`,
                        return: periodReturn * 100,
                        localReturn: localReturn * 100,
                        currencyReturn: currencyReturn * 100,
                        contribution: contribution * 100,
                        cumulativeReturn: method === 'geometric' ? 
                            (cumulativeReturn - 1) * 100 : 
                            cumulativeReturn * 100
                    });
                });
                
                // Calculate annualized return
                const totalReturn = method === 'geometric' ? 
                    cumulativeReturn - 1 : 
                    cumulativeReturn;
                const years = periods.length / 12; // Assuming monthly periods
                const annualizedReturn = method === 'geometric' ?
                    Math.pow(cumulativeReturn, 1 / years) - 1 :
                    totalReturn / years;
                
                return {
                    totalReturn: totalReturn * 100,
                    annualizedReturn: annualizedReturn * 100,
                    periods: periodResults,
                    method,
                    volatility: calculatePeriodVolatility(periods),
                    bestPeriod: periodResults.reduce((best, p) => 
                        p.return > best.return ? p : best),
                    worstPeriod: periodResults.reduce((worst, p) => 
                        p.return < worst.return ? p : worst)
                };
            };
            
            /**
             * Helper to calculate period volatility
             */
            const calculatePeriodVolatility = (periods) => {
                if (periods.length < 2) return 0;
                
                const returns = periods.map(p => p.return || 0);
                const mean = returns.reduce((sum, r) => sum + r, 0) / returns.length;
                const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
                return Math.sqrt(variance) * Math.sqrt(12) * 100; // Annualized
            };
            
            // ----- RATINGS ANALYSIS LOGIC -----
            
            /**
             * Calculate Buffett Checklist score for a company
             * @param {object} company - Company data with financials
             * @param {object} weights - Criteria weights
             * @returns {object} Buffett checklist analysis
             */
            const calculateBuffettChecklistScore = (company, weights = {}) => {
                const defaultWeights = {
                    simpleBusiness: 0.10,
                    consistentHistory: 0.10,
                    favorableProspects: 0.10,
                    rationalManagement: 0.08,
                    attractivePrice: 0.12,
                    highROE: 0.12,
                    lowDebt: 0.08,
                    highMargins: 0.10,
                    moat: 0.15,
                    ownerEarnings: 0.05
                };
                
                const criteriaWeights = { ...defaultWeights, ...weights };
                const scores = {};
                let totalScore = 0;
                
                // Simple Business (based on business complexity metrics)
                scores.simpleBusiness = company.businessSegments <= 3 ? 90 : 
                                        company.businessSegments <= 5 ? 70 : 50;
                
                // Consistent Operating History
                const consistencyYears = company.profitableYears || 0;
                scores.consistentHistory = Math.min(100, consistencyYears * 10);
                
                // Favorable Long-term Prospects
                const growthRate = company.expectedGrowth || 0;
                scores.favorableProspects = Math.min(100, 50 + growthRate * 2);
                
                // Rational Management
                scores.rationalManagement = company.managementScore || 75;
                
                // Attractive Price
                const peRatio = company.peRatio || 20;
                scores.attractivePrice = peRatio < 15 ? 90 :
                                         peRatio < 20 ? 70 :
                                         peRatio < 25 ? 50 : 30;
                
                // High ROE
                const roe = company.roe || 15;
                scores.highROE = Math.min(100, roe * 4);
                
                // Low Debt
                const debtToEquity = company.debtToEquity || 0.5;
                scores.lowDebt = debtToEquity < 0.3 ? 95 :
                                debtToEquity < 0.5 ? 80 :
                                debtToEquity < 1.0 ? 60 : 30;
                
                // High Profit Margins
                const profitMargin = company.profitMargin || 10;
                scores.highMargins = Math.min(100, profitMargin * 5);
                
                // Moat/Competitive Advantage
                scores.moat = company.moatScore || 70;
                
                // Owner Earnings Growth
                const earningsGrowth = company.earningsGrowth || 5;
                scores.ownerEarnings = Math.min(100, 50 + earningsGrowth * 3);
                
                // Calculate weighted total score
                Object.keys(scores).forEach(criteria => {
                    totalScore += scores[criteria] * criteriaWeights[criteria];
                });
                
                // Determine recommendation
                let recommendation = 'Hold';
                if (totalScore >= 85) recommendation = 'Strong Buy';
                else if (totalScore >= 75) recommendation = 'Buy';
                else if (totalScore >= 60) recommendation = 'Hold';
                else if (totalScore >= 45) recommendation = 'Sell';
                else recommendation = 'Strong Sell';
                
                return {
                    scores,
                    totalScore: Math.round(totalScore),
                    recommendation,
                    strengths: Object.keys(scores).filter(k => scores[k] >= 80),
                    weaknesses: Object.keys(scores).filter(k => scores[k] < 60),
                    details: Object.keys(scores).map(criteria => ({
                        criteria: criteria.replace(/([A-Z])/g, ' $1').trim(),
                        score: scores[criteria],
                        weight: criteriaWeights[criteria] * 100,
                        contribution: scores[criteria] * criteriaWeights[criteria]
                    }))
                };
            };
            
            /**
             * Calculate Dividend Safety Score
             * @param {object} dividendData - Company dividend metrics
             * @returns {object} Dividend safety analysis
             */
            const calculateDividendSafetyScore = (dividendData) => {
                const factors = {};
                let totalScore = 0;
                
                // Payout Ratio (lower is safer)
                const payoutRatio = dividendData.payoutRatio || 50;
                factors.payoutRatio = payoutRatio < 40 ? 95 :
                                      payoutRatio < 60 ? 85 :
                                      payoutRatio < 80 ? 65 : 30;
                
                // Free Cash Flow Coverage
                const fcfCoverage = dividendData.fcfCoverage || 1.5;
                factors.freeCashFlow = fcfCoverage > 2 ? 95 :
                                      fcfCoverage > 1.5 ? 85 :
                                      fcfCoverage > 1 ? 70 : 40;
                
                // Debt/Equity Ratio
                const debtEquity = dividendData.debtToEquity || 0.5;
                factors.debtEquity = debtEquity < 0.3 ? 90 :
                                    debtEquity < 0.6 ? 75 :
                                    debtEquity < 1 ? 60 : 30;
                
                // Earnings Stability
                const earningsVolatility = dividendData.earningsVolatility || 10;
                factors.earningsStability = earningsVolatility < 5 ? 95 :
                                           earningsVolatility < 10 ? 85 :
                                           earningsVolatility < 20 ? 70 : 50;
                
                // Revenue Growth
                const revenueGrowth = dividendData.revenueGrowth || 5;
                factors.revenueGrowth = revenueGrowth > 10 ? 90 :
                                       revenueGrowth > 5 ? 80 :
                                       revenueGrowth > 0 ? 70 : 50;
                
                // Dividend History (years of consistent payments)
                const dividendYears = dividendData.consecutiveDividendYears || 10;
                factors.dividendHistory = Math.min(100, dividendYears * 3);
                
                // Calculate weighted score
                const weights = {
                    payoutRatio: 0.20,
                    freeCashFlow: 0.20,
                    debtEquity: 0.15,
                    earningsStability: 0.20,
                    revenueGrowth: 0.10,
                    dividendHistory: 0.15
                };
                
                Object.keys(factors).forEach(factor => {
                    totalScore += factors[factor] * weights[factor];
                });
                
                // Determine safety rating
                let safetyRating = 'Safe';
                if (totalScore >= 85) safetyRating = 'Very Safe';
                else if (totalScore >= 70) safetyRating = 'Safe';
                else if (totalScore >= 55) safetyRating = 'Moderate';
                else if (totalScore >= 40) safetyRating = 'At Risk';
                else safetyRating = 'High Risk';
                
                return {
                    overallScore: Math.round(totalScore),
                    factors,
                    safetyRating,
                    sustainabilityYears: estimateDividendSustainability(dividendData),
                    cutProbability: 100 - totalScore,
                    keyRisks: identifyDividendRisks(factors)
                };
            };
            
            /**
             * Helper to estimate dividend sustainability
             */
            const estimateDividendSustainability = (data) => {
                const payoutRatio = data.payoutRatio || 50;
                const earningsGrowth = data.earningsGrowth || 5;
                
                if (payoutRatio >= 100) return 0;
                if (payoutRatio >= 90) return 1;
                if (earningsGrowth > 10 && payoutRatio < 60) return 10;
                if (earningsGrowth > 5 && payoutRatio < 70) return 5;
                return 3;
            };
            
            /**
             * Helper to identify dividend risks
             */
            const identifyDividendRisks = (factors) => {
                const risks = [];
                if (factors.payoutRatio < 70) risks.push('High payout ratio');
                if (factors.freeCashFlow < 70) risks.push('Weak cash flow coverage');
                if (factors.debtEquity < 60) risks.push('High debt levels');
                if (factors.earningsStability < 70) risks.push('Volatile earnings');
                return risks;
            };
            
            /**
             * Calculate Moat Strength
             * @param {object} companyData - Company competitive advantage data
             * @returns {object} Moat strength analysis
             */
            const calculateMoatStrength = (companyData) => {
                const moatFactors = {};
                
                // Brand Value
                const brandValue = companyData.brandValue || 50;
                moatFactors.brandValue = Math.min(100, brandValue * 1.5);
                
                // Switching Costs
                const switchingCosts = companyData.switchingCosts || 'medium';
                moatFactors.switchingCosts = switchingCosts === 'high' ? 90 :
                                             switchingCosts === 'medium' ? 60 : 30;
                
                // Network Effects
                const networkEffects = companyData.networkEffects || false;
                moatFactors.networkEffects = networkEffects ? 85 : 40;
                
                // Cost Advantages
                const costAdvantage = companyData.costAdvantage || 0;
                moatFactors.costAdvantage = Math.min(100, 50 + costAdvantage * 2);
                
                // Intangible Assets (patents, licenses, etc.)
                const intangibles = companyData.intangibleAssets || 50;
                moatFactors.intangibleAssets = intangibles;
                
                // Efficient Scale
                const marketShare = companyData.marketShare || 20;
                moatFactors.efficientScale = Math.min(100, marketShare * 2.5);
                
                // Calculate overall moat strength
                const moatScore = Object.values(moatFactors).reduce((sum, score) => 
                    sum + score, 0) / Object.keys(moatFactors).length;
                
                // Determine moat rating
                let moatRating = 'No Moat';
                if (moatScore >= 80) moatRating = 'Wide Moat';
                else if (moatScore >= 60) moatRating = 'Narrow Moat';
                else if (moatScore >= 40) moatRating = 'Emerging Moat';
                
                // Compare to industry average
                const industryAverage = companyData.industryAverageMoat || 50;
                const relativeStrength = moatScore - industryAverage;
                
                return {
                    moatScore: Math.round(moatScore),
                    moatRating,
                    factors: moatFactors,
                    relativeToIndustry: relativeStrength > 0 ? 'Above Average' : 'Below Average',
                    competitiveAdvantages: Object.keys(moatFactors)
                        .filter(k => moatFactors[k] >= 70)
                        .map(k => k.replace(/([A-Z])/g, ' $1').trim()),
                    vulnerabilities: Object.keys(moatFactors)
                        .filter(k => moatFactors[k] < 50)
                        .map(k => k.replace(/([A-Z])/g, ' $1').trim()),
                    sustainabilityYears: estimateMoatDurability(moatScore, companyData)
                };
            };
            
            /**
             * Helper to estimate moat durability
             */
            const estimateMoatDurability = (moatScore, data) => {
                if (moatScore >= 80 && data.innovationRate > 5) return 20;
                if (moatScore >= 70) return 15;
                if (moatScore >= 60) return 10;
                if (moatScore >= 50) return 7;
                return 5;
            };
            
            /**
             * Calculate Resilience Rating
             * @param {object} resilienceData - Company resilience metrics
             * @returns {object} Resilience analysis
             */
            const calculateResilienceRating = (resilienceData) => {
                const factors = {};
                
                // Financial Strength
                const cashRatio = resilienceData.cashRatio || 0.5;
                const debtCoverage = resilienceData.debtCoverage || 2;
                factors.financialStrength = (Math.min(100, cashRatio * 100) + 
                                            Math.min(100, debtCoverage * 25)) / 2;
                
                // Market Position
                const marketShare = resilienceData.marketShare || 15;
                const competitivePosition = resilienceData.competitiveRank || 5;
                factors.marketPosition = Math.min(100, marketShare * 3 + (10 - competitivePosition) * 5);
                
                // Adaptability
                const innovationScore = resilienceData.innovationScore || 50;
                const pivotHistory = resilienceData.successfulPivots || 0;
                factors.adaptability = Math.min(100, innovationScore + pivotHistory * 10);
                
                // Management Quality
                const managementTenure = resilienceData.avgManagementTenure || 5;
                const executionScore = resilienceData.executionScore || 70;
                factors.managementQuality = (Math.min(100, managementTenure * 10) + executionScore) / 2;
                
                // Diversification
                const revenueSources = resilienceData.revenueSources || 3;
                const geographicDiversity = resilienceData.geographicMarkets || 5;
                factors.diversification = Math.min(100, (revenueSources * 10 + geographicDiversity * 5));
                
                // Innovation Capability
                const rdSpending = resilienceData.rdAsPercentOfRevenue || 5;
                const patentCount = resilienceData.patents || 10;
                factors.innovation = Math.min(100, rdSpending * 5 + Math.log10(patentCount + 1) * 20);
                
                // Calculate overall resilience
                const resilienceScore = Object.values(factors).reduce((sum, score) => 
                    sum + score, 0) / Object.keys(factors).length;
                
                // Determine resilience rating
                let rating = 'Moderate';
                let status = 'Stable';
                
                if (resilienceScore >= 85) {
                    rating = 'Exceptional';
                    status = 'Antifragile';
                } else if (resilienceScore >= 75) {
                    rating = 'Strong';
                    status = 'Robust';
                } else if (resilienceScore >= 60) {
                    rating = 'Good';
                    status = 'Resilient';
                } else if (resilienceScore >= 45) {
                    rating = 'Moderate';
                    status = 'Stable';
                } else {
                    rating = 'Weak';
                    status = 'Vulnerable';
                }
                
                return {
                    resilienceScore: Math.round(resilienceScore),
                    rating,
                    status,
                    factors,
                    crisisReadiness: resilienceScore > 70,
                    recoveryTime: estimateRecoveryTime(resilienceScore),
                    keyStrengths: Object.keys(factors)
                        .filter(k => factors[k] >= 75)
                        .map(k => k.replace(/([A-Z])/g, ' $1').trim()),
                    improvements: Object.keys(factors)
                        .filter(k => factors[k] < 60)
                        .map(k => k.replace(/([A-Z])/g, ' $1').trim())
                };
            };
            
            /**
             * Helper to estimate recovery time from crisis
             */
            const estimateRecoveryTime = (resilienceScore) => {
                if (resilienceScore >= 80) return '3-6 months';
                if (resilienceScore >= 70) return '6-12 months';
                if (resilienceScore >= 60) return '12-18 months';
                if (resilienceScore >= 50) return '18-24 months';
                return '24+ months';
            };
            
            
            // ============================================
            // Caching Layer (React Query-Inspired)
            // ============================================
            
            /**
             * CacheManager - React Query-inspired caching system
             * 
             * Features:
             * - Query key-based caching
             * - Stale-while-revalidate pattern
             * - Automatic garbage collection
             * - Request deduplication
             * - Cache invalidation on mutations
             * - Background refetching
             * 
             * Inspired by React Query patterns from the TypeScript implementation
             */
            const CacheManager = (() => {
                // Cache storage
                const cache = new Map();
                const querySubscribers = new Map();
                const activeRequests = new Map();
                const cacheTimers = new Map();
                
                // Default configuration (matching React Query defaults)
                const defaultConfig = {
                    staleTime: 5 * 60 * 1000,      // 5 minutes - how long data is fresh
                    gcTime: 10 * 60 * 1000,         // 10 minutes - garbage collection time
                    retryCount: 3,                   // Number of retry attempts
                    retryDelay: 1000,                // Base retry delay
                    refetchOnWindowFocus: true,     // Refetch when window gains focus
                    refetchOnReconnect: true,        // Refetch on network reconnect
                    backgroundRefetchInterval: null  // Background refetch interval (null = disabled)
                };
                
                /**
                 * Generate cache key from query key array or string
                 * @param {Array|string} queryKey - Query key
                 * @returns {string} Serialized cache key
                 */
                const getCacheKey = (queryKey) => {
                    if (typeof queryKey === 'string') return queryKey;
                    if (Array.isArray(queryKey)) return JSON.stringify(queryKey);
                    return JSON.stringify([queryKey]);
                };
                
                /**
                 * Check if cached data is stale
                 * @param {object} entry - Cache entry
                 * @param {number} staleTime - Stale time in ms
                 * @returns {boolean} Whether data is stale
                 */
                const isStale = (entry, staleTime = defaultConfig.staleTime) => {
                    if (!entry) return true;
                    const age = Date.now() - entry.timestamp;
                    return age > staleTime;
                };
                
                /**
                 * Check if cache should be garbage collected
                 * @param {object} entry - Cache entry
                 * @param {number} gcTime - Garbage collection time in ms
                 * @returns {boolean} Whether to garbage collect
                 */
                const shouldGarbageCollect = (entry, gcTime = defaultConfig.gcTime) => {
                    if (!entry) return true;
                    const age = Date.now() - entry.lastAccessed;
                    return age > gcTime && entry.subscribers === 0;
                };
                
                /**
                 * Get cached data with stale-while-revalidate pattern
                 * @param {Array|string} queryKey - Query key
                 * @param {Function} queryFn - Function to fetch data
                 * @param {object} options - Query options
                 * @returns {Promise} Cached or fresh data
                 */
                const get = async (queryKey, queryFn, options = {}) => {
                    const key = getCacheKey(queryKey);
                    const config = { ...defaultConfig, ...options };
                    
                    // Check cache
                    const cached = cache.get(key);
                    
                    // Update last accessed time
                    if (cached) {
                        cached.lastAccessed = Date.now();
                    }
                    
                    // Return fresh cached data immediately
                    if (cached && !isStale(cached, config.staleTime)) {
                        return { 
                            data: cached.data, 
                            error: null, 
                            isStale: false,
                            isFetching: false,
                            isFromCache: true
                        };
                    }
                    
                    // Check if there's already an active request (deduplication)
                    if (activeRequests.has(key)) {
                        const activePromise = activeRequests.get(key);
                        return activePromise;
                    }
                    
                    // Stale-while-revalidate: Return stale data immediately while fetching
                    if (cached && isStale(cached, config.staleTime)) {
                        // Start background refetch
                        const refetchPromise = fetchWithRetry(queryFn, config)
                            .then(data => {
                                set(queryKey, data);
                                notifySubscribers(key, { data, error: null, isStale: false });
                                return { data, error: null, isStale: false, isFetching: false };
                            })
                            .catch(error => {
                                // Keep stale data on error
                                notifySubscribers(key, { data: cached.data, error, isStale: true });
                                return { data: cached.data, error, isStale: true, isFetching: false };
                            })
                            .finally(() => {
                                activeRequests.delete(key);
                            });
                        
                        activeRequests.set(key, refetchPromise);
                        
                        // Return stale data immediately
                        return { 
                            data: cached.data, 
                            error: null, 
                            isStale: true, 
                            isFetching: true,
                            isFromCache: true
                        };
                    }
                    
                    // No cache or expired - fetch fresh data
                    const fetchPromise = fetchWithRetry(queryFn, config)
                        .then(data => {
                            set(queryKey, data);
                            notifySubscribers(key, { data, error: null, isStale: false });
                            return { data, error: null, isStale: false, isFetching: false };
                        })
                        .catch(error => {
                            notifySubscribers(key, { data: null, error, isStale: false });
                            throw error;
                        })
                        .finally(() => {
                            activeRequests.delete(key);
                        });
                    
                    activeRequests.set(key, fetchPromise);
                    return fetchPromise;
                };
                
                /**
                 * Fetch with retry logic
                 * @param {Function} queryFn - Query function
                 * @param {object} config - Configuration
                 * @returns {Promise} Query result
                 */
                const fetchWithRetry = async (queryFn, config) => {
                    let lastError;
                    
                    for (let attempt = 0; attempt <= config.retryCount; attempt++) {
                        try {
                            const result = await queryFn();
                            return result;
                        } catch (error) {
                            lastError = error;
                            
                            // Don't retry on 4xx errors
                            if (error.response?.status >= 400 && error.response?.status < 500) {
                                throw error;
                            }
                            
                            // Wait before retry with exponential backoff
                            if (attempt < config.retryCount) {
                                const delay = Math.min(
                                    config.retryDelay * Math.pow(2, attempt),
                                    30000
                                );
                                await new Promise(resolve => setTimeout(resolve, delay));
                            }
                        }
                    }
                    
                    throw lastError;
                };
                
                /**
                 * Set data in cache
                 * @param {Array|string} queryKey - Query key
                 * @param {any} data - Data to cache
                 * @param {object} options - Cache options
                 */
                const set = (queryKey, data, options = {}) => {
                    const key = getCacheKey(queryKey);
                    const config = { ...defaultConfig, ...options };
                    
                    // Clear existing garbage collection timer
                    if (cacheTimers.has(key)) {
                        clearTimeout(cacheTimers.get(key));
                    }
                    
                    // Store in cache
                    cache.set(key, {
                        data,
                        timestamp: Date.now(),
                        lastAccessed: Date.now(),
                        subscribers: querySubscribers.get(key)?.size || 0
                    });
                    
                    // Schedule garbage collection
                    const gcTimer = setTimeout(() => {
                        const entry = cache.get(key);
                        if (entry && shouldGarbageCollect(entry, config.gcTime)) {
                            cache.delete(key);
                            cacheTimers.delete(key);
                        }
                    }, config.gcTime);
                    
                    cacheTimers.set(key, gcTimer);
                };
                
                /**
                 * Invalidate cache entries
                 * @param {Array|string|Function} queryKey - Query key or predicate
                 */
                const invalidate = (queryKey) => {
                    if (typeof queryKey === 'function') {
                        // Invalidate by predicate
                        for (const [key, entry] of cache.entries()) {
                            if (queryKey(key, entry.data)) {
                                cache.delete(key);
                                notifySubscribers(key, { invalidated: true });
                            }
                        }
                    } else {
                        // Invalidate by key
                        const key = getCacheKey(queryKey);
                        
                        // Support partial matching for array keys
                        if (Array.isArray(queryKey)) {
                            const prefix = JSON.stringify(queryKey);
                            for (const cacheKey of cache.keys()) {
                                if (cacheKey.startsWith(prefix.slice(0, -1))) {
                                    cache.delete(cacheKey);
                                    notifySubscribers(cacheKey, { invalidated: true });
                                }
                            }
                        } else {
                            cache.delete(key);
                            notifySubscribers(key, { invalidated: true });
                        }
                    }
                };
                
                /**
                 * Clear entire cache
                 */
                const clear = () => {
                    cache.clear();
                    activeRequests.clear();
                    
                    // Clear all timers
                    for (const timer of cacheTimers.values()) {
                        clearTimeout(timer);
                    }
                    cacheTimers.clear();
                    
                    // Notify all subscribers
                    for (const key of querySubscribers.keys()) {
                        notifySubscribers(key, { invalidated: true });
                    }
                };
                
                /**
                 * Subscribe to cache updates
                 * @param {Array|string} queryKey - Query key
                 * @param {Function} callback - Callback function
                 * @returns {Function} Unsubscribe function
                 */
                const subscribe = (queryKey, callback) => {
                    const key = getCacheKey(queryKey);
                    
                    if (!querySubscribers.has(key)) {
                        querySubscribers.set(key, new Set());
                    }
                    
                    querySubscribers.get(key).add(callback);
                    
                    // Update subscriber count
                    const entry = cache.get(key);
                    if (entry) {
                        entry.subscribers = querySubscribers.get(key).size;
                    }
                    
                    // Return unsubscribe function
                    return () => {
                        const subscribers = querySubscribers.get(key);
                        if (subscribers) {
                            subscribers.delete(callback);
                            if (subscribers.size === 0) {
                                querySubscribers.delete(key);
                            }
                            
                            // Update subscriber count
                            const entry = cache.get(key);
                            if (entry) {
                                entry.subscribers = subscribers.size;
                            }
                        }
                    };
                };
                
                /**
                 * Notify subscribers of cache updates
                 * @param {string} key - Cache key
                 * @param {object} update - Update data
                 */
                const notifySubscribers = (key, update) => {
                    const subscribers = querySubscribers.get(key);
                    if (subscribers) {
                        subscribers.forEach(callback => {
                            try {
                                callback(update);
                            } catch (error) {
                                console.error('Error in cache subscriber:', error);
                            }
                        });
                    }
                };
                
                /**
                 * Prefetch data into cache
                 * @param {Array|string} queryKey - Query key
                 * @param {Function} queryFn - Query function
                 * @param {object} options - Options
                 */
                const prefetch = async (queryKey, queryFn, options = {}) => {
                    const key = getCacheKey(queryKey);
                    const cached = cache.get(key);
                    
                    // Only prefetch if not cached or stale
                    if (!cached || isStale(cached, options.staleTime)) {
                        try {
                            const data = await queryFn();
                            set(queryKey, data, options);
                        } catch (error) {
                            console.error('Prefetch error:', error);
                        }
                    }
                };
                
                /**
                 * Get cache statistics
                 * @returns {object} Cache statistics
                 */
                const getStats = () => {
                    const entries = Array.from(cache.entries());
                    const now = Date.now();
                    
                    return {
                        size: cache.size,
                        activeRequests: activeRequests.size,
                        subscribers: querySubscribers.size,
                        entries: entries.map(([key, entry]) => ({
                            key,
                            age: now - entry.timestamp,
                            lastAccessed: now - entry.lastAccessed,
                            isStale: isStale(entry),
                            subscribers: entry.subscribers
                        }))
                    };
                };
                
                // Setup window focus refetching
                if (typeof window !== 'undefined' && defaultConfig.refetchOnWindowFocus) {
                    window.addEventListener('focus', () => {
                        // Refetch all queries with subscribers
                        for (const [key, subscribers] of querySubscribers.entries()) {
                            if (subscribers.size > 0) {
                                const cached = cache.get(key);
                                if (cached && isStale(cached)) {
                                    // Mark for refetch
                                    cached.timestamp = 0;
                                }
                            }
                        }
                    });
                }
                
                // Setup online/offline handling
                if (typeof window !== 'undefined' && defaultConfig.refetchOnReconnect) {
                    window.addEventListener('online', () => {
                        // Trigger refetch for stale queries
                        for (const [key, entry] of cache.entries()) {
                            if (isStale(entry)) {
                                notifySubscribers(key, { refetch: true });
                            }
                        }
                    });
                }
                
                return {
                    get,
                    set,
                    invalidate,
                    clear,
                    subscribe,
                    prefetch,
                    getStats,
                    isStale,
                    config: defaultConfig
                };
            })();
            
            /**
             * Query Key Generator - Helper for consistent query keys
             * Follows React Query patterns from queries.ts
             */
            const queryKeys = {
                portfolio: (id) => ['portfolio', id],
                macro: () => ['macro'],
                holdings: (id) => ['holdings', id],
                scenarios: (id) => ['scenarios', id],
                alerts: (id) => ['alerts', id],
                reports: (id) => ['reports', id],
                user: () => ['user'],
                health: () => ['health'],
                pattern: (pattern, params) => ['pattern', pattern, params]
            };
            
            /**
             * Enhanced API Client with Caching
             * Wraps the existing apiClient with caching layer
             */
            const cachedApiClient = {
                ...apiClient,
                
                /**
                 * Execute pattern with caching
                 * @param {string} pattern - Pattern name
                 * @param {object} inputs - Pattern inputs (must be named 'inputs' for backend compatibility)
                 * @param {object} options - Cache options
                 */
                executePattern: async (pattern, inputs = {}, options = {}) => {
                    const queryKey = queryKeys.pattern(pattern, inputs);
                    
                    // Different cache times for different patterns
                    const cacheConfig = {
                        staleTime: pattern.includes('overview') ? 2 * 60 * 1000 : 5 * 60 * 1000,
                        ...options
                    };
                    
                    return CacheManager.get(
                        queryKey,
                        () => apiClient.executePattern(pattern, inputs),
                        cacheConfig
                    );
                },
                
                /**
                 * Get portfolio overview with caching
                 * @param {string} portfolioId - Portfolio ID
                 * @param {object} options - Cache options
                 */
                getPortfolioOverview: async (portfolioId, options = {}) => {
                    const queryKey = queryKeys.portfolio(portfolioId);
                    
                    return CacheManager.get(
                        queryKey,
                        () => apiClient.executePattern('portfolio_overview', { 
                            portfolio_id: portfolioId,
                            lookback_days: 252 
                        }),
                        { staleTime: 2 * 60 * 1000, ...options }
                    );
                },
                
                /**
                 * Get macro dashboard with caching
                 * @param {object} options - Cache options
                 */
                getMacroDashboard: async (options = {}) => {
                    const queryKey = queryKeys.macro();
                    
                    return CacheManager.get(
                        queryKey,
                        () => apiClient.executePattern('macro_cycles_overview', {}),
                        { staleTime: 10 * 60 * 1000, ...options }
                    );
                },
                
                /**
                 * Get holdings with caching
                 * @param {string} portfolioId - Portfolio ID
                 * @param {object} options - Cache options
                 */
                getHoldings: async (portfolioId, options = {}) => {
                    const queryKey = queryKeys.holdings(portfolioId);
                    
                    return CacheManager.get(
                        queryKey,
                        () => apiClient.getHoldings(portfolioId),
                        { staleTime: 5 * 60 * 1000, ...options }
                    );
                },
                
                /**
                 * Get alerts with caching
                 * @param {string} portfolioId - Portfolio ID
                 * @param {object} options - Cache options
                 */
                getAlerts: async (portfolioId, options = {}) => {
                    const queryKey = queryKeys.alerts(portfolioId);
                    
                    return CacheManager.get(
                        queryKey,
                        () => apiClient.executePattern('macro_trend_monitor', {
                            portfolio_id: portfolioId
                        }),
                        { staleTime: 1 * 60 * 1000, ...options }
                    );
                },
                
                /**
                 * Invalidate portfolio-related caches
                 * @param {string} portfolioId - Portfolio ID
                 */
                invalidatePortfolio: (portfolioId) => {
                    CacheManager.invalidate(queryKeys.portfolio(portfolioId));
                    CacheManager.invalidate(queryKeys.holdings(portfolioId));
                    CacheManager.invalidate(queryKeys.scenarios(portfolioId));
                    CacheManager.invalidate(queryKeys.alerts(portfolioId));
                    CacheManager.invalidate(queryKeys.reports(portfolioId));
                },
                
                /**
                 * Invalidate all caches
                 */
                invalidateAll: () => {
                    CacheManager.clear();
                },
                
                /**
                 * Prefetch portfolio data
                 * @param {string} portfolioId - Portfolio ID
                 */
                prefetchPortfolio: async (portfolioId) => {
                    await CacheManager.prefetch(
                        queryKeys.portfolio(portfolioId),
                        () => apiClient.executePattern('portfolio_overview', {
                            portfolio_id: portfolioId,
                            lookback_days: 252
                        }),
                        { staleTime: 2 * 60 * 1000 }
                    );
                    
                    await CacheManager.prefetch(
                        queryKeys.holdings(portfolioId),
                        () => apiClient.getHoldings(portfolioId),
                        { staleTime: 5 * 60 * 1000 }
                    );
                }
            };

            // ============================================
            // ERROR HANDLING UTILITIES
            // ============================================
            
            /**
             * Error Classification and User-Friendly Messaging
             * Maps technical errors to helpful user messages
             */
            const ErrorHandler = {
                /**
                 * Map error codes to user-friendly messages
                 */
                errorMessages: {
                    400: "There was an issue with your request. Please check your input and try again.",
                    401: "Your session has expired. Please log in again to continue.",
                    403: "You don't have permission to access this resource.",
                    404: "The requested data could not be found. It may have been moved or deleted.",
                    408: "The request took too long. Please check your connection and try again.",
                    429: "Too many requests. Please wait a moment and try again.",
                    500: "We're experiencing a server issue. Please try again in a few moments.",
                    502: "Unable to connect to the server. Please check your connection.",
                    503: "The service is temporarily unavailable. Please try again later.",
                    504: "The server took too long to respond. Please try again.",
                    
                    // Network errors
                    'NETWORK_ERROR': "Unable to connect to the server. Please check your internet connection.",
                    'TIMEOUT': "The request timed out. Please try again.",
                    'UNKNOWN_ERROR': "An unexpected error occurred. Please try again.",
                    
                    // Application-specific errors
                    'INVALID_PORTFOLIO': "The selected portfolio could not be found.",
                    'INSUFFICIENT_DATA': "Not enough data available for this analysis.",
                    'CALCULATION_ERROR': "Unable to complete the calculation. Please try again.",
                    'AUTH_EXPIRED': "Your authentication has expired. Please log in again.",
                    'RATE_LIMIT': "You've made too many requests. Please wait a moment.",
                    'VALIDATION_ERROR': "Please check your input and try again.",
                    'CONNECTION_LOST': "Connection to the server was lost. Attempting to reconnect..."
                },
                
                /**
                 * Classify error type for appropriate handling
                 */
                classifyError: (error) => {
                    // Check if it's a network error
                    if (!window.navigator.onLine) {
                        return {
                            type: 'network',
                            severity: 'warning',
                            message: ErrorHandler.errorMessages['NETWORK_ERROR'],
                            canRetry: true
                        };
                    }
                    
                    // Check for response status codes
                    if (error.response) {
                        const status = error.response.status;
                        const message = ErrorHandler.errorMessages[status] || 
                                       error.response.data?.detail || 
                                       error.response.data?.message || 
                                       'An error occurred. Please try again.';
                        
                        return {
                            type: status >= 500 ? 'server' : 'client',
                            severity: status >= 500 ? 'error' : 'warning',
                            status,
                            message,
                            canRetry: status >= 500 || status === 408 || status === 429,
                            details: error.response.data
                        };
                    }
                    
                    // Check for request errors (no response received)
                    if (error.request) {
                        return {
                            type: 'network',
                            severity: 'error',
                            message: ErrorHandler.errorMessages['NETWORK_ERROR'],
                            canRetry: true
                        };
                    }
                    
                    // Check for timeout errors
                    if (error.code === 'ECONNABORTED' || error.message.includes('timeout')) {
                        return {
                            type: 'timeout',
                            severity: 'warning',
                            message: ErrorHandler.errorMessages['TIMEOUT'],
                            canRetry: true
                        };
                    }
                    
                    // Default to unknown error
                    return {
                        type: 'unknown',
                        severity: 'error',
                        message: error.message || ErrorHandler.errorMessages['UNKNOWN_ERROR'],
                        canRetry: true
                    };
                },
                
                /**
                 * Get actionable suggestions based on error type
                 */
                getSuggestions: (errorInfo) => {
                    const suggestions = [];
                    
                    switch (errorInfo.type) {
                        case 'network':
                            suggestions.push('Check your internet connection');
                            suggestions.push('Try refreshing the page');
                            suggestions.push('Check if you are behind a firewall or VPN');
                            break;
                        case 'server':
                            suggestions.push('Wait a few moments and try again');
                            suggestions.push('If the problem persists, contact support');
                            break;
                        case 'client':
                            if (errorInfo.status === 401) {
                                suggestions.push('Click here to log in again');
                            } else if (errorInfo.status === 403) {
                                suggestions.push('Contact your administrator for access');
                            } else if (errorInfo.status === 429) {
                                suggestions.push('Wait a few seconds before retrying');
                            }
                            break;
                        case 'timeout':
                            suggestions.push('Check your internet connection speed');
                            suggestions.push('Try again with a smaller data range');
                            break;
                    }
                    
                    return suggestions;
                },
                
                /**
                 * Log error for debugging (in development mode)
                 */
                logError: (error, context = {}) => {
                    if (console.group) {
                        console.group('%cðŸ”´ Error Details', 'color: #ef4444; font-weight: bold');
                        console.error('Error:', error);
                        console.log('Context:', context);
                        console.log('Stack:', error.stack);
                        console.log('Timestamp:', new Date().toISOString());
                        console.groupEnd();
                    } else {
                        console.error('Error occurred:', error, context);
                    }
                }
            };
            
            /**
             * Form Validation Utilities
             */
            const FormValidator = {
                /**
                 * Validate email format
                 */
                validateEmail: (email) => {
                    const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                    if (!email) return { valid: false, message: 'Email is required' };
                    if (!re.test(email)) return { valid: false, message: 'Please enter a valid email address' };
                    return { valid: true };
                },
                
                /**
                 * Validate password strength
                 */
                validatePassword: (password) => {
                    if (!password) return { valid: false, message: 'Password is required' };
                    if (password.length < 8) return { valid: false, message: 'Password must be at least 8 characters' };
                    return { valid: true };
                },
                
                /**
                 * Validate required field
                 */
                validateRequired: (value, fieldName) => {
                    if (!value || value.toString().trim() === '') {
                        return { valid: false, message: `${fieldName} is required` };
                    }
                    return { valid: true };
                },
                
                /**
                 * Validate number range
                 */
                validateRange: (value, min, max, fieldName) => {
                    const num = parseFloat(value);
                    if (isNaN(num)) return { valid: false, message: `${fieldName} must be a number` };
                    if (num < min) return { valid: false, message: `${fieldName} must be at least ${min}` };
                    if (num > max) return { valid: false, message: `${fieldName} must be at most ${max}` };
                    return { valid: true };
                }
            };
            
            // ============================================
            // ERROR BOUNDARY COMPONENT
            // ============================================
            
            /**
             * ErrorBoundary - Catches JavaScript errors in component tree
             * Provides fallback UI and recovery options
             */
            class ErrorBoundary extends React.Component {
                constructor(props) {
                    super(props);
                    this.state = {
                        hasError: false,
                        error: null,
                        errorInfo: null,
                        errorCount: 0,
                        isAutoRecovering: false,
                        autoRecoveryMessage: null
                    };
                    this.autoRecoveryTimer = null;
                }
                
                static getDerivedStateFromError(error) {
                    // Update state to render error UI
                    return { hasError: true };
                }
                
                componentDidCatch(error, errorInfo) {
                    // Log error details for debugging
                    ErrorHandler.logError(error, { 
                        componentStack: errorInfo.componentStack,
                        props: this.props 
                    });
                    
                    // Check for portfolio_id error and auto-recover
                    const errorMessage = error?.toString() || '';
                    const errorStack = error?.stack || '';
                    const componentStack = errorInfo?.componentStack || '';
                    
                    if (errorMessage.includes('portfolio_id') || 
                        errorStack.includes('portfolio_id') ||
                        componentStack.includes('portfolio_id')) {
                        
                        console.log('[ErrorBoundary] Detected portfolio_id error - initiating auto-recovery');
                        console.log('[ErrorBoundary] Error details:', {
                            message: errorMessage,
                            stack: errorStack.slice(0, 500),
                            component: componentStack.slice(0, 500)
                        });
                        
                        // Set auto-recovery state
                        this.setState({
                            error,
                            errorInfo,
                            isAutoRecovering: true,
                            autoRecoveryMessage: 'Refreshing portfolio data...',
                            errorCount: this.state.errorCount + 1
                        });
                        
                        // Clear any existing timer
                        if (this.autoRecoveryTimer) {
                            clearTimeout(this.autoRecoveryTimer);
                        }
                        
                        // Auto-reload after 2 seconds
                        this.autoRecoveryTimer = setTimeout(() => {
                            console.log('[ErrorBoundary] Auto-recovery: Reloading page');
                            window.location.reload();
                        }, 2000);
                        
                    } else {
                        // Regular error handling for non-portfolio_id errors
                        console.log('[ErrorBoundary] Regular error caught:', errorMessage);
                        
                        // Update state with error details
                        this.setState(prevState => ({
                            error,
                            errorInfo,
                            errorCount: prevState.errorCount + 1,
                            isAutoRecovering: false,
                            autoRecoveryMessage: null
                        }));
                    }
                    
                    // Report to error tracking service (if configured)
                    if (window.errorReporter) {
                        window.errorReporter.report(error, errorInfo);
                    }
                }
                
                componentWillUnmount() {
                    // Clean up timer on unmount
                    if (this.autoRecoveryTimer) {
                        clearTimeout(this.autoRecoveryTimer);
                    }
                }
                
                handleReset = () => {
                    // Clear any auto-recovery timer
                    if (this.autoRecoveryTimer) {
                        clearTimeout(this.autoRecoveryTimer);
                        this.autoRecoveryTimer = null;
                    }
                    
                    // Reset error boundary state
                    this.setState({
                        hasError: false,
                        error: null,
                        errorInfo: null,
                        isAutoRecovering: false,
                        autoRecoveryMessage: null
                    });
                    
                    // Optionally reload the page if errors persist
                    if (this.state.errorCount > 3) {
                        window.location.reload();
                    }
                };
                
                render() {
                    if (this.state.hasError) {
                        // Check if auto-recovering
                        if (this.state.isAutoRecovering) {
                            console.log('[ErrorBoundary] Rendering auto-recovery UI');
                            return e('div', { className: 'error-boundary-fallback' },
                                e('div', { className: 'error-container' },
                                    e('div', { className: 'error-icon' }, 'ðŸ”„'),
                                    e('h2', { className: 'error-title' }, 'Auto-Recovery in Progress'),
                                    e('p', { className: 'error-description' }, 
                                        this.state.autoRecoveryMessage || 'Refreshing portfolio data...'
                                    ),
                                    e('div', { className: 'loading' },
                                        e('div', { className: 'spinner' })
                                    ),
                                    e('p', { 
                                        style: { 
                                            marginTop: '1rem', 
                                            fontSize: '0.875rem', 
                                            color: 'var(--text-secondary)' 
                                        } 
                                    }, 'Page will reload automatically in a moment...')
                                )
                            );
                        }
                        
                        // Render regular error fallback UI
                        return e('div', { className: 'error-boundary-fallback' },
                            e('div', { className: 'error-container' },
                                e('div', { className: 'error-icon' }, 'âš ï¸'),
                                e('h2', { className: 'error-title' }, 'Something went wrong'),
                                e('p', { className: 'error-description' }, 
                                    'An unexpected error occurred. The application has logged this error and it will be reviewed.'
                                ),
                                
                                // Show error details in development
                                (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') && 
                                this.state.error && e('details', { className: 'error-details' },
                                    e('summary', null, 'Error Details (Development Only)'),
                                    e('pre', { className: 'error-stack' }, 
                                        this.state.error.toString(),
                                        '\n\n',
                                        this.state.errorInfo?.componentStack
                                    )
                                ),
                                
                                e('div', { className: 'error-actions' },
                                    e('button', { 
                                        className: 'btn btn-primary',
                                        onClick: this.handleReset
                                    }, 'Try Again'),
                                    e('button', { 
                                        className: 'btn',
                                        onClick: () => window.location.reload()
                                    }, 'Reload Page')
                                )
                            )
                        );
                    }
                    
                    return this.props.children;
                }
            }
            
            // ============================================
            // DATA PROVENANCE COMPONENTS
            // ============================================
            // Navigation Structure with All 52 Capabilities
            // ============================================
            
            const navigationStructure = [
                {
                    section: 'Portfolio',
                    items: [
                        { id: 'dashboard', label: 'Dashboard', path: '/dashboard' },
                        { id: 'holdings', label: 'Holdings', path: '/holdings' },
                        { id: 'transactions', label: 'Transactions', path: '/transactions' },
                        { id: 'performance', label: 'Performance', path: '/performance' },
                        { id: 'corporate-actions', label: 'Corporate Actions', path: '/corporate-actions' }
                    ]
                },
                {
                    section: 'Analysis',
                    items: [
                        { id: 'macro-cycles', label: 'Macro Cycles', path: '/macro-cycles' },
                        { id: 'scenarios', label: 'Scenarios', path: '/scenarios' },
                        { id: 'risk', label: 'Risk Analytics', path: '/risk' },
                        { id: 'attribution', label: 'Attribution', path: '/attribution' }
                    ]
                },
                {
                    section: 'Intelligence',
                    items: [
                        { id: 'optimizer', label: 'Optimizer', path: '/optimizer' },
                        { id: 'ratings', label: 'Ratings', path: '/ratings' },
                        { id: 'ai-insights', label: 'AI Insights', path: '/ai-insights' },
                        { id: 'ai-assistant', label: 'AI Assistant', path: '/ai-assistant' },
                        { id: 'market-data', label: 'Market Data', path: '/market-data' }
                    ]
                },
                {
                    section: 'Operations',
                    items: [
                        { id: 'alerts', label: 'Alerts', path: '/alerts' },
                        { id: 'reports', label: 'Reports', path: '/reports' },
                        { id: 'settings', label: 'Settings', path: '/settings' }
                    ]
                }
            ];
            
            // ============================================
            // Component: Main Application
            // ============================================
            
            function App() {
                const [isAuthenticated, setIsAuthenticated] = useState(!!TokenManager.getToken());
                const [currentPage, setCurrentPage] = useState('dashboard');
                const [user, setUser] = useState(TokenManager.getUser());
                const [sidebarOpen, setSidebarOpen] = useState(false);
                
                useEffect(() => {
                    // Check if user is authenticated on mount
                    const token = TokenManager.getToken();
                    const savedUser = TokenManager.getUser();
                    if (token && savedUser) {
                        setIsAuthenticated(true);
                        setUser(savedUser);
                    }
                    
                    // Listen for navigation events
                    const handleNavigate = (event) => {
                        if (event.detail && event.detail.page) {
                            setCurrentPage(event.detail.page);
                        }
                    };
                    window.addEventListener('navigate', handleNavigate);
                    
                    return () => {
                        window.removeEventListener('navigate', handleNavigate);
                    };
                }, []);
                
                const handleLogin = (userData) => {
                    setIsAuthenticated(true);
                    setUser(userData);
                    setCurrentPage('dashboard');
                };
                
                const handleLogout = () => {
                    TokenManager.removeToken();
                    TokenManager.removeUser();
                    // Clear portfolio selection from localStorage
                    localStorage.removeItem('selectedPortfolioId');
                    setIsAuthenticated(false);
                    setUser(null);
                    setCurrentPage('dashboard');
                };
                
                const toggleSidebar = () => {
                    setSidebarOpen(!sidebarOpen);
                };
                
                const renderPage = () => {
                    switch(currentPage) {
                        case 'dashboard':
                            return e(DashboardPage);
                        case 'holdings':
                            return e(HoldingsPage);
                        case 'security-detail':
                            return e(SecurityDetailPage);
                        case 'transactions':
                            return e(TransactionsPage);
                        case 'performance':
                            return e(PerformancePage);
                        case 'macro-cycles':
                            return e(MacroCyclesPage);
                        case 'scenarios':
                            return e(ScenariosPage);
                        case 'risk':
                            return e(RiskPage);
                        case 'attribution':
                            return e(AttributionPage);
                        case 'optimizer':
                            return e(OptimizerPage);
                        case 'ratings':
                            return e(RatingsPage);
                        case 'ai-insights':
                            return e(AIInsightsPage);
                        case 'ai-assistant':
                            return e(AIAssistantPage);
                        case 'alerts':
                            return e(AlertsPage);
                        case 'reports':
                            return e(ReportsPage);
                        case 'corporate-actions':
                            return e(CorporateActionsPage);
                        case 'market-data':
                            return e(MarketDataPage);
                        case 'settings':
                            return e(SettingsPage);
                        default:
                            return e('div', null, 'Page not found');
                    }
                };
                
                if (!isAuthenticated) {
                    return e(LoginPage, { onLogin: handleLogin });
                }
                
                return e(UserContextProvider, { user },
                    e('div', { className: 'dashboard' },
                        // Sidebar
                        e('aside', { className: `sidebar ${sidebarOpen ? 'open' : ''}` },
                        e('div', { className: 'sidebar-header' },
                            e('div', { className: 'sidebar-brand' }, 'DawsOS')
                        ),
                        e('nav', { className: 'sidebar-nav' },
                            navigationStructure.map(section =>
                                e('div', { key: section.section, className: 'nav-section' },
                                    e('div', { className: 'nav-section-title' }, section.section),
                                    section.items.map(item =>
                                        e('button', {
                                            key: item.id,
                                            className: `nav-item ${currentPage === item.id ? 'active' : ''}`,
                                            onClick: () => {
                                                setCurrentPage(item.id);
                                                setSidebarOpen(false);
                                            }
                                        }, item.label)
                                    )
                                )
                            )
                        )
                    ),
                    
                    // Main Content
                    e('div', { className: `main-wrapper ${!sidebarOpen ? '' : 'expanded'}` },
                        // Header
                        e('header', { className: 'header-bar' },
                            e('div', { className: 'header-left' },
                                e('button', { 
                                    className: 'menu-toggle',
                                    onClick: toggleSidebar
                                }, 'â˜°'),
                                e('div', { className: 'breadcrumb' },
                                    e('span', null, 'DawsOS'),
                                    e('span', { className: 'breadcrumb-separator' }, '/'),
                                    e('span', { className: 'breadcrumb-current' }, 
                                        navigationStructure.flatMap(s => s.items)
                                            .find(i => i.id === currentPage)?.label || 'Dashboard')
                                )
                            ),
                            e('div', { className: 'header-right' },
                                e(PortfolioSelector),
                                e('div', { className: 'user-info' }, user?.email || 'User'),
                                e('button', { 
                                    className: 'btn-logout',
                                    onClick: handleLogout
                                }, 'Logout')
                            )
                        ),
                        
                        // Page Content
                        e('main', { className: 'page-content' },
                            renderPage()
                        )
                    )
                    )
                );
            }

            // Wrap the App with ErrorBoundary and render the application
            ReactDOM.render(
                e(ErrorBoundary, null, e(App)),
                document.getElementById('root')
            );
        }
    </script>
</body>
</html>