<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DawsOS Portfolio Intelligence Platform</title>
    
    <!-- Cache control meta tags -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <!-- React UMD builds -->
    <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/axios@1.6.2/dist/axios.min.js"></script>
    <!-- Chart.js for visualizations -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    
    <!-- Version Management (load first for cache-busting) -->
    <script src="frontend/version.js?v=20250115"></script>
    
    <!-- Logger Module (load early for other modules to use) -->
    <script src="frontend/logger.js?v=20250115"></script>
    
    <!-- Module Dependency Validation (load early) -->
    <script src="frontend/module-dependencies.js?v=20250115"></script>
    
    <!-- API Client Module -->
    <script src="frontend/api-client.js?v=20250115"></script>
    
    <!-- Form Validator Module -->
    <script src="frontend/form-validator.js?v=20250115"></script>
    
    <!-- Error Handler Module -->
    <script src="frontend/error-handler.js?v=20250115"></script>
    
    <!-- Utility Functions Module -->
    <script src="frontend/utils.js?v=20250115"></script>
    <!-- Panel Components Module -->
    <script src="frontend/panels.js?v=20250115"></script>
    <!-- Context System Module (MUST load before pattern-system and pages) -->
    <script src="frontend/context.js?v=20250115"></script>
    <!-- Pattern System Module (depends on context, utils, panels) -->
    <script src="frontend/pattern-system.js?v=20250115"></script>
    <!-- Page Components Module (depends on ALL modules above) -->
    <script src="frontend/pages.js?v=20250115"></script>
    
    <!-- Namespace Validation (load after all modules) -->
    <script src="frontend/namespace-validator.js?v=20250115"></script>
    
    <!-- Note: Cache-busting is handled via version query parameters in script src attributes -->
    <!-- The version.js module provides version info, but we don't modify script tags after load -->
    <!-- This prevents race conditions and ensures scripts load correctly -->

    <!-- Professional Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@300;400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="frontend/styles.css">
</head>
<body>
    <div id="root"></div>
    
    <script>
        // Wait for all scripts to load before initializing
        function initializeApp() {
            // Check if React is loaded
            if (typeof React === 'undefined' || typeof ReactDOM === 'undefined') {
                document.getElementById('root').innerHTML = '<div style="padding: 2rem; text-align: center;">Loading React framework...</div>';
                setTimeout(() => location.reload(), 2000);
                return;
            }
            
            // Check if all required namespaces are loaded
            if (!window.DawsOS || !window.DawsOS.APIClient || !window.DawsOS.Utils || 
                !window.DawsOS.Panels || !window.DawsOS.Pages || 
                !window.DawsOS.Context || !window.DawsOS.PatternSystem) {
                console.log('Waiting for modules to load...', {
                    DawsOS: !!window.DawsOS,
                    APIClient: !!window.DawsOS?.APIClient,
                    Utils: !!window.DawsOS?.Utils,
                    Panels: !!window.DawsOS?.Panels,
                    Pages: !!window.DawsOS?.Pages,
                    Context: !!window.DawsOS?.Context,
                    PatternSystem: !!window.DawsOS?.PatternSystem
                });
                // Wait a bit and try again
                setTimeout(initializeApp, 100);
                return;
            }
            
            // All modules loaded, initialize the application
            const { useState, useEffect, useCallback, useRef } = React;
            const e = React.createElement;
            
            // ============================================
            // API Client is now loaded from frontend/api-client.js
            // All API functionality (TokenManager, apiClient, etc.)
            // is available globally from the external module
            // ============================================

            // ============================================
            // Import from External Modules
            // ============================================
            // Utility functions are in DawsOS.Utils namespace
            const {
                formatCurrency,
                formatPercentage,
                formatNumber,
                formatDate,
                formatValue,
                getColorClass,
                LoadingSpinner,
                ErrorMessage,
                EmptyState,
                RetryableError,
                useCachedQuery,
                useCachedMutation
            } = DawsOS.Utils;

            // Panel components are in DawsOS.Panels namespace
            const {
                MetricsGridPanel,
                DataTablePanel,
                ChartPanel,
                TimeSeriesChartPanel,
                ScorecardPanel,
                AlertPanel,
                HoldingsTable
            } = DawsOS.Panels;

            // Page components are in DawsOS.Pages namespace
            const {
                LoginPage,
                DashboardPage,
                DashboardPageLegacy,
                HoldingsPage,
                SecurityDetailPage,
                TransactionsPage,
                PerformancePage,
                MacroCyclesPage,
                ScenariosPage,
                RiskPage,
                AttributionPage,
                OptimizerPage,
                RatingsPage,
                AIInsightsPage,
                AIAssistantPage,
                AlertsPage,
                ReportsPage,
                CorporateActionsPage,
                MarketDataPage,
                SettingsPage
            } = DawsOS.Pages;

            // Context system is in DawsOS.Context namespace
            const {
                getCurrentPortfolioId,
                UserContext,
                UserContextProvider,
                useUserContext,
                PortfolioSelector
            } = DawsOS.Context;

            // Pattern system is in DawsOS.PatternSystem namespace
            const {
                getDataByPath,
                PatternRenderer,
                PanelRenderer,
                patternRegistry,
                queryKeys,
                queryHelpers
            } = DawsOS.PatternSystem;

            // ===== UNIFIED PATTERN INTEGRATION SYSTEM =====
            
            
            // ----- OPTIMIZATION LOGIC -----
            
            /**
             * Generate trade proposals based on portfolio optimization
             * @param {object} portfolio - Current portfolio
             * @param {object} targetAllocation - Target allocation
             * @param {object} constraints - Trading constraints
             * @returns {Array} Trade proposals
             */
            const generateTradeProposals = (portfolio, targetAllocation, constraints = {}) => {
                const proposals = [];
                const currentHoldings = portfolio.holdings || [];
                const totalValue = portfolio.value || 0;
                const maxTrades = constraints.maxTrades || 10;
                const minTradeSize = constraints.minTradeSize || 1000;
                const maxPositionSize = constraints.maxPositionSize || 0.15;
                
                // Calculate current allocations
                const currentAllocations = {};
                currentHoldings.forEach(holding => {
                    const allocation = holding.value / totalValue;
                    currentAllocations[holding.symbol] = allocation;
                });
                
                // Identify required trades
                Object.keys(targetAllocation).forEach(symbol => {
                    const current = currentAllocations[symbol] || 0;
                    const target = targetAllocation[symbol];
                    const difference = target - current;
                    const dollarDifference = difference * totalValue;
                    
                    if (Math.abs(dollarDifference) > minTradeSize) {
                        const holding = currentHoldings.find(h => h.symbol === symbol) || {};
                        const price = holding.price || 100;
                        const shares = Math.round(dollarDifference / price);
                        
                        proposals.push({
                            id: proposals.length + 1,
                            action: dollarDifference > 0 ? 'BUY' : 'SELL',
                            symbol,
                            shares: Math.abs(shares),
                            price,
                            value: Math.abs(dollarDifference),
                            currentAllocation: current * 100,
                            targetAllocation: target * 100,
                            impact: (difference * 100).toFixed(2) + '%',
                            reason: generateTradeReason(current, target, symbol),
                            confidence: calculateTradeConfidence(difference, symbol),
                            priority: Math.abs(difference) // Higher difference = higher priority
                        });
                    }
                });
                
                // Sort by priority and limit to maxTrades
                return proposals
                    .sort((a, b) => b.priority - a.priority)
                    .slice(0, maxTrades)
                    .map((trade, index) => ({ ...trade, id: index + 1 }));
            };
            
            /**
             * Helper function to generate trade reason
             */
            const generateTradeReason = (current, target, symbol) => {
                const diff = target - current;
                if (diff > 0.05) return `Increase ${symbol} exposure to target`;
                if (diff < -0.05) return `Reduce ${symbol} concentration`;
                if (diff > 0) return `Rebalance ${symbol} to target weight`;
                return `Trim ${symbol} position`;
            };
            
            /**
             * Helper function to calculate trade confidence
             */
            const calculateTradeConfidence = (difference, symbol) => {
                const baseConfidence = 70;
                const differenceBonus = Math.min(Math.abs(difference) * 100, 20);
                const volatilityPenalty = Math.random() * 10; // Placeholder for actual volatility
                return Math.min(95, Math.max(50, baseConfidence + differenceBonus - volatilityPenalty));
            };
            
            /**
             * Analyze trade impact on portfolio metrics
             * @param {Array} trades - Proposed trades
             * @param {object} portfolio - Current portfolio
             * @param {object} marketData - Market data for calculations
             * @returns {object} Impact analysis results
             */
            const analyzeTradeImpact = (trades, portfolio, marketData = {}) => {
                const currentMetrics = portfolio.metrics || {};
                const currentReturn = currentMetrics.expectedReturn || 8;
                const currentVolatility = currentMetrics.volatility || 15;
                const currentSharpe = currentMetrics.sharpe || 0.85;
                const currentBeta = currentMetrics.beta || 1.0;
                
                // Simulate post-trade metrics
                let portfolioAfterTrades = { ...portfolio };
                let totalBuyValue = 0;
                let totalSellValue = 0;
                
                trades.forEach(trade => {
                    if (trade.action === 'BUY') {
                        totalBuyValue += trade.value || (trade.shares * trade.price);
                    } else {
                        totalSellValue += trade.value || (trade.shares * trade.price);
                    }
                });
                
                // Calculate expected changes (simplified model)
                const netChange = totalBuyValue - totalSellValue;
                const rebalancingEffect = Math.abs(netChange) / portfolio.value;
                
                // Estimate new metrics
                const returnImprovement = rebalancingEffect * 0.15; // 15% improvement per 1% rebalanced
                const volatilityReduction = rebalancingEffect * 0.2; // 20% reduction per 1% rebalanced
                const betaChange = netChange > 0 ? 0.05 : -0.05; // Directional beta change
                
                const optimizedReturn = currentReturn * (1 + returnImprovement);
                const optimizedVolatility = currentVolatility * (1 - volatilityReduction);
                const optimizedSharpe = calculateSharpeRatio(optimizedReturn / 100, 0.02, optimizedVolatility / 100);
                const optimizedBeta = currentBeta + betaChange;
                
                // Calculate improvement metrics
                const metrics = [
                    {
                        metric: 'Expected Return',
                        current: currentReturn,
                        optimized: optimizedReturn,
                        change: ((optimizedReturn - currentReturn) / currentReturn) * 100,
                        improvement: optimizedReturn > currentReturn
                    },
                    {
                        metric: 'Volatility',
                        current: currentVolatility,
                        optimized: optimizedVolatility,
                        change: ((optimizedVolatility - currentVolatility) / currentVolatility) * 100,
                        improvement: optimizedVolatility < currentVolatility
                    },
                    {
                        metric: 'Sharpe Ratio',
                        current: currentSharpe,
                        optimized: optimizedSharpe,
                        change: optimizedSharpe - currentSharpe,
                        improvement: optimizedSharpe > currentSharpe
                    },
                    {
                        metric: 'Beta',
                        current: currentBeta,
                        optimized: optimizedBeta,
                        change: optimizedBeta - currentBeta,
                        improvement: Math.abs(optimizedBeta - 1) < Math.abs(currentBeta - 1)
                    }
                ];
                
                // Calculate overall improvement score
                const improvementScore = metrics.reduce((score, m) => 
                    score + (m.improvement ? 1 : 0), 0) / metrics.length;
                
                return {
                    metrics,
                    totalBuyValue,
                    totalSellValue,
                    netChange,
                    rebalancingPercentage: rebalancingEffect * 100,
                    improvementScore,
                    recommendation: improvementScore > 0.5 ? 'Execute trades' : 'Review trades',
                    estimatedCost: trades.reduce((sum, t) => sum + (t.shares * t.price * 0.001), 0), // 0.1% transaction cost
                    riskReduction: volatilityReduction * 100,
                    returnEnhancement: returnImprovement * 100
                };
            };
            
            /**
             * Calculate efficient frontier points for portfolio optimization
             * @param {Array} assets - Array of assets with returns and risks
             * @param {object} constraints - Optimization constraints
             * @returns {Array} Efficient frontier points
             */
            const calculateEfficientFrontier = (assets, constraints = {}) => {
                const minRisk = constraints.minRisk || 5;
                const maxRisk = constraints.maxRisk || 25;
                const riskStep = constraints.riskStep || 1;
                const riskFreeRate = constraints.riskFreeRate || 0.02;
                
                const frontierPoints = [];
                
                for (let risk = minRisk; risk <= maxRisk; risk += riskStep) {
                    // Simplified efficient frontier calculation
                    // In reality, this would use mean-variance optimization
                    const baseReturn = 4;
                    const riskPremium = 0.4;
                    const diminishingFactor = Math.log10(risk / 5);
                    
                    // Calculate return for this risk level
                    const expectedReturn = baseReturn + (risk * riskPremium * diminishingFactor);
                    
                    // Add some randomness to simulate real portfolio variations
                    const variation = (Math.random() - 0.5) * 2;
                    const adjustedReturn = expectedReturn + variation;
                    
                    // Calculate Sharpe ratio for this point
                    const sharpe = (adjustedReturn - riskFreeRate * 100) / risk;
                    
                    frontierPoints.push({
                        risk,
                        return: adjustedReturn,
                        sharpe,
                        isEfficient: sharpe > 0.3,
                        allocation: generateOptimalAllocation(risk)
                    });
                }
                
                return frontierPoints;
            };
            
            /**
             * Helper to generate optimal allocation for a given risk level
             */
            const generateOptimalAllocation = (riskLevel) => {
                const conservativeRatio = Math.max(0, (25 - riskLevel) / 20);
                const aggressiveRatio = Math.min(1, riskLevel / 25);
                
                return {
                    stocks: aggressiveRatio * 70,
                    bonds: conservativeRatio * 40,
                    alternatives: 10 + (riskLevel / 25) * 10,
                    cash: Math.max(5, 20 - riskLevel)
                };
            };
            
            /**
             * Optimize portfolio for risk/return characteristics
             * @param {object} portfolio - Current portfolio
             * @param {object} objectives - Optimization objectives
             * @param {object} constraints - Optimization constraints
             * @returns {object} Optimization results
             */
            const optimizeRiskReturn = (portfolio, objectives = {}, constraints = {}) => {
                const targetReturn = objectives.targetReturn || 10;
                const maxRisk = objectives.maxRisk || 20;
                const riskTolerance = objectives.riskTolerance || 'moderate';
                
                // Current portfolio metrics
                const currentMetrics = {
                    return: portfolio.metrics?.expectedReturn || 8,
                    risk: portfolio.metrics?.volatility || 15,
                    sharpe: portfolio.metrics?.sharpe || 0.85,
                    diversification: portfolio.metrics?.diversification || 0.7
                };
                
                // Define optimal targets based on risk tolerance
                let optimalTargets = {};
                switch (riskTolerance) {
                    case 'conservative':
                        optimalTargets = {
                            return: 6,
                            risk: 10,
                            stockAllocation: 40,
                            bondAllocation: 50,
                            alternativeAllocation: 10
                        };
                        break;
                    case 'aggressive':
                        optimalTargets = {
                            return: 12,
                            risk: 20,
                            stockAllocation: 80,
                            bondAllocation: 10,
                            alternativeAllocation: 10
                        };
                        break;
                    default: // moderate
                        optimalTargets = {
                            return: 9,
                            risk: 15,
                            stockAllocation: 60,
                            bondAllocation: 30,
                            alternativeAllocation: 10
                        };
                }
                
                // Calculate optimization actions needed
                const actions = [];
                
                if (currentMetrics.risk > optimalTargets.risk) {
                    actions.push({
                        type: 'REDUCE_RISK',
                        description: 'Reduce portfolio volatility',
                        target: optimalTargets.risk,
                        current: currentMetrics.risk,
                        priority: 'HIGH'
                    });
                }
                
                if (currentMetrics.return < optimalTargets.return * 0.9) {
                    actions.push({
                        type: 'INCREASE_RETURN',
                        description: 'Enhance expected returns',
                        target: optimalTargets.return,
                        current: currentMetrics.return,
                        priority: 'MEDIUM'
                    });
                }
                
                if (currentMetrics.sharpe < 1.0) {
                    actions.push({
                        type: 'IMPROVE_EFFICIENCY',
                        description: 'Improve risk-adjusted returns',
                        target: 1.0,
                        current: currentMetrics.sharpe,
                        priority: 'HIGH'
                    });
                }
                
                // Generate rebalancing recommendations
                const rebalancingNeeded = Math.abs(currentMetrics.return - optimalTargets.return) > 1 ||
                                         Math.abs(currentMetrics.risk - optimalTargets.risk) > 2;
                
                return {
                    currentMetrics,
                    optimalTargets,
                    actions,
                    rebalancingNeeded,
                    optimizationScore: calculateOptimizationScore(currentMetrics, optimalTargets),
                    recommendations: generateOptimizationRecommendations(actions),
                    estimatedImprovement: {
                        return: optimalTargets.return - currentMetrics.return,
                        risk: currentMetrics.risk - optimalTargets.risk,
                        sharpe: (optimalTargets.return - 2) / optimalTargets.risk - currentMetrics.sharpe
                    }
                };
            };
            
            /**
             * Helper to calculate optimization score
             */
            const calculateOptimizationScore = (current, target) => {
                const returnScore = Math.min(current.return / target.return, 1);
                const riskScore = Math.min(target.risk / current.risk, 1);
                const sharpeScore = Math.min(current.sharpe / 1.0, 1);
                return (returnScore + riskScore + sharpeScore) / 3 * 10;
            };
            
            /**
             * Helper to generate optimization recommendations
             */
            const generateOptimizationRecommendations = (actions) => {
                const recommendations = [];
                actions.forEach(action => {
                    switch (action.type) {
                        case 'REDUCE_RISK':
                            recommendations.push('Increase allocation to bonds and defensive assets');
                            recommendations.push('Consider adding low-correlation alternatives');
                            break;
                        case 'INCREASE_RETURN':
                            recommendations.push('Increase exposure to growth assets');
                            recommendations.push('Consider sector rotation to high-momentum areas');
                            break;
                        case 'IMPROVE_EFFICIENCY':
                            recommendations.push('Rebalance to optimal asset allocation');
                            recommendations.push('Reduce concentration in underperforming positions');
                            break;
                    }
                });
                return recommendations;
            };
            
            // ----- ATTRIBUTION ANALYSIS LOGIC -----
            
            /**
             * Calculate currency attribution for multi-currency portfolios
             * @param {Array} positions - Portfolio positions with currency exposure
             * @param {object} fxRates - Foreign exchange rates
             * @param {string} baseCurrency - Base currency for reporting
             * @returns {object} Currency attribution analysis
             */
            const calculateCurrencyAttribution = (positions, fxRates, baseCurrency = 'USD') => {
                const attribution = {
                    localReturns: {},
                    fxImpact: {},
                    crossEffects: {},
                    totalAttribution: 0
                };
                
                positions.forEach(position => {
                    const currency = position.currency || baseCurrency;
                    const localReturn = position.localReturn || 0;
                    const fxReturn = fxRates[currency]?.change || 0;
                    
                    // Local return contribution
                    const localContribution = position.weight * localReturn;
                    
                    // FX impact contribution
                    const fxContribution = position.weight * fxReturn;
                    
                    // Cross effect (interaction between local and FX)
                    const crossEffect = position.weight * localReturn * fxReturn;
                    
                    // Aggregate by currency
                    if (!attribution.localReturns[currency]) {
                        attribution.localReturns[currency] = 0;
                        attribution.fxImpact[currency] = 0;
                        attribution.crossEffects[currency] = 0;
                    }
                    
                    attribution.localReturns[currency] += localContribution;
                    attribution.fxImpact[currency] += fxContribution;
                    attribution.crossEffects[currency] += crossEffect;
                });
                
                // Calculate totals
                const totalLocal = Object.values(attribution.localReturns).reduce((sum, val) => sum + val, 0);
                const totalFx = Object.values(attribution.fxImpact).reduce((sum, val) => sum + val, 0);
                const totalCross = Object.values(attribution.crossEffects).reduce((sum, val) => sum + val, 0);
                
                attribution.totalAttribution = totalLocal + totalFx + totalCross;
                
                // Add summary statistics
                attribution.summary = {
                    localReturnContribution: totalLocal,
                    fxContribution: totalFx,
                    interactionEffect: totalCross,
                    totalReturn: attribution.totalAttribution,
                    fxImpactPercentage: totalFx / Math.abs(attribution.totalAttribution) * 100
                };
                
                // Identify major currency impacts
                attribution.majorImpacts = Object.keys(attribution.fxImpact)
                    .map(currency => ({
                        currency,
                        impact: attribution.fxImpact[currency],
                        percentage: attribution.fxImpact[currency] / totalFx * 100
                    }))
                    .sort((a, b) => Math.abs(b.impact) - Math.abs(a.impact))
                    .slice(0, 5);
                
                return attribution;
            };
            
            /**
             * Calculate factor attribution (selection, allocation, interaction)
             * @param {object} portfolio - Portfolio with holdings and returns
             * @param {object} benchmark - Benchmark for comparison
             * @param {Array} factors - Factors to analyze
             * @returns {object} Factor attribution results
             */
            const calculateFactorAttribution = (portfolio, benchmark, factors = []) => {
                const defaultFactors = ['selection', 'allocation', 'interaction'];
                const analysisFactors = factors.length > 0 ? factors : defaultFactors;
                
                const attribution = {
                    factors: {},
                    totalActive: 0,
                    contributions: []
                };
                
                // Calculate portfolio and benchmark returns
                const portfolioReturn = portfolio.return || 0;
                const benchmarkReturn = benchmark.return || 0;
                const activeReturn = portfolioReturn - benchmarkReturn;
                
                // Selection effect (stock picking within sectors)
                const selectionEffect = portfolio.sectors?.reduce((total, sector) => {
                    const sectorReturn = sector.return || 0;
                    const benchmarkSectorReturn = benchmark.sectors?.find(s => s.name === sector.name)?.return || 0;
                    const benchmarkWeight = benchmark.sectors?.find(s => s.name === sector.name)?.weight || 0;
                    return total + benchmarkWeight * (sectorReturn - benchmarkSectorReturn);
                }, 0) || 0;
                
                // Allocation effect (sector weighting decisions)
                const allocationEffect = portfolio.sectors?.reduce((total, sector) => {
                    const portfolioWeight = sector.weight || 0;
                    const benchmarkWeight = benchmark.sectors?.find(s => s.name === sector.name)?.weight || 0;
                    const benchmarkSectorReturn = benchmark.sectors?.find(s => s.name === sector.name)?.return || 0;
                    return total + (portfolioWeight - benchmarkWeight) * (benchmarkSectorReturn - benchmarkReturn);
                }, 0) || 0;
                
                // Interaction effect (combined selection and allocation)
                const interactionEffect = portfolio.sectors?.reduce((total, sector) => {
                    const portfolioWeight = sector.weight || 0;
                    const benchmarkWeight = benchmark.sectors?.find(s => s.name === sector.name)?.weight || 0;
                    const sectorReturn = sector.return || 0;
                    const benchmarkSectorReturn = benchmark.sectors?.find(s => s.name === sector.name)?.return || 0;
                    return total + (portfolioWeight - benchmarkWeight) * (sectorReturn - benchmarkSectorReturn);
                }, 0) || 0;
                
                // Other factors (trading costs, currency, etc.)
                const tradingEffect = portfolio.tradingCosts || 0;
                const currencyEffect = portfolio.currencyImpact || 0;
                const residual = activeReturn - (selectionEffect + allocationEffect + interactionEffect + tradingEffect + currencyEffect);
                
                // Populate attribution object
                attribution.factors = {
                    selection: selectionEffect,
                    allocation: allocationEffect,
                    interaction: interactionEffect,
                    trading: tradingEffect,
                    currency: currencyEffect,
                    residual: residual
                };
                
                attribution.totalActive = activeReturn;
                
                // Calculate contribution percentages
                Object.keys(attribution.factors).forEach(factor => {
                    const contribution = attribution.factors[factor];
                    attribution.contributions.push({
                        factor: factor.charAt(0).toUpperCase() + factor.slice(1),
                        contribution: contribution * 100,
                        percentage: activeReturn !== 0 ? (contribution / activeReturn) * 100 : 0
                    });
                });
                
                return attribution;
            };
            
            /**
             * Calculate sector performance attribution
             * @param {Array} sectors - Portfolio sectors with weights and returns
             * @param {Array} benchmarkSectors - Benchmark sectors
             * @returns {object} Sector attribution analysis
             */
            const calculateSectorAttribution = (sectors, benchmarkSectors) => {
                const attribution = [];
                const totalPortfolioReturn = sectors.reduce((sum, s) => sum + s.weight * s.return, 0);
                const totalBenchmarkReturn = benchmarkSectors.reduce((sum, s) => sum + s.weight * s.return, 0);
                
                sectors.forEach(sector => {
                    const benchmarkSector = benchmarkSectors.find(s => s.name === sector.name) || {
                        weight: 0,
                        return: totalBenchmarkReturn
                    };
                    
                    // Calculate attribution components
                    const allocationEffect = (sector.weight - benchmarkSector.weight) * 
                                            (benchmarkSector.return - totalBenchmarkReturn);
                    const selectionEffect = benchmarkSector.weight * 
                                          (sector.return - benchmarkSector.return);
                    const interactionEffect = (sector.weight - benchmarkSector.weight) * 
                                             (sector.return - benchmarkSector.return);
                    
                    const totalContribution = allocationEffect + selectionEffect + interactionEffect;
                    
                    attribution.push({
                        sector: sector.name,
                        weight: sector.weight,
                        return: sector.return,
                        benchmarkWeight: benchmarkSector.weight,
                        benchmarkReturn: benchmarkSector.return,
                        activeWeight: sector.weight - benchmarkSector.weight,
                        activeReturn: sector.return - benchmarkSector.return,
                        allocation: allocationEffect * 100,
                        selection: selectionEffect * 100,
                        interaction: interactionEffect * 100,
                        contribution: totalContribution * 100
                    });
                });
                
                // Sort by total contribution
                attribution.sort((a, b) => Math.abs(b.contribution) - Math.abs(a.contribution));
                
                return {
                    sectorDetails: attribution,
                    totalActive: (totalPortfolioReturn - totalBenchmarkReturn) * 100,
                    topContributors: attribution.slice(0, 3),
                    bottomContributors: attribution.slice(-3),
                    summary: {
                        allocationTotal: attribution.reduce((sum, s) => sum + s.allocation, 0),
                        selectionTotal: attribution.reduce((sum, s) => sum + s.selection, 0),
                        interactionTotal: attribution.reduce((sum, s) => sum + s.interaction, 0)
                    }
                };
            };
            
            /**
             * Calculate multi-period attribution (linking returns over time)
             * @param {Array} periods - Array of period data with returns
             * @param {string} method - Attribution method ('arithmetic' or 'geometric')
             * @returns {object} Multi-period attribution results
             */
            const calculateMultiPeriodAttribution = (periods, method = 'geometric') => {
                if (!periods || periods.length === 0) {
                    return {
                        totalReturn: 0,
                        annualizedReturn: 0,
                        periods: []
                    };
                }
                
                let cumulativeReturn = 1;
                const periodResults = [];
                
                periods.forEach((period, index) => {
                    const periodReturn = period.return || 0;
                    const localReturn = period.localReturn || periodReturn;
                    const currencyReturn = period.currencyReturn || 0;
                    
                    let contribution;
                    if (method === 'geometric') {
                        // Geometric linking
                        contribution = cumulativeReturn * periodReturn;
                        cumulativeReturn *= (1 + periodReturn);
                    } else {
                        // Arithmetic linking
                        contribution = periodReturn;
                        cumulativeReturn += periodReturn;
                    }
                    
                    periodResults.push({
                        period: period.name || `Period ${index + 1}`,
                        return: periodReturn * 100,
                        localReturn: localReturn * 100,
                        currencyReturn: currencyReturn * 100,
                        contribution: contribution * 100,
                        cumulativeReturn: method === 'geometric' ? 
                            (cumulativeReturn - 1) * 100 : 
                            cumulativeReturn * 100
                    });
                });
                
                // Calculate annualized return
                const totalReturn = method === 'geometric' ? 
                    cumulativeReturn - 1 : 
                    cumulativeReturn;
                const years = periods.length / 12; // Assuming monthly periods
                const annualizedReturn = method === 'geometric' ?
                    Math.pow(cumulativeReturn, 1 / years) - 1 :
                    totalReturn / years;
                
                return {
                    totalReturn: totalReturn * 100,
                    annualizedReturn: annualizedReturn * 100,
                    periods: periodResults,
                    method,
                    volatility: calculatePeriodVolatility(periods),
                    bestPeriod: periodResults.reduce((best, p) => 
                        p.return > best.return ? p : best),
                    worstPeriod: periodResults.reduce((worst, p) => 
                        p.return < worst.return ? p : worst)
                };
            };
            
            /**
             * Helper to calculate period volatility
             */
            const calculatePeriodVolatility = (periods) => {
                if (periods.length < 2) return 0;
                
                const returns = periods.map(p => p.return || 0);
                const mean = returns.reduce((sum, r) => sum + r, 0) / returns.length;
                const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
                return Math.sqrt(variance) * Math.sqrt(12) * 100; // Annualized
            };
            
            // ----- RATINGS ANALYSIS LOGIC -----
            
            /**
             * Calculate Buffett Checklist score for a company
             * @param {object} company - Company data with financials
             * @param {object} weights - Criteria weights
             * @returns {object} Buffett checklist analysis
             */
            const calculateBuffettChecklistScore = (company, weights = {}) => {
                const defaultWeights = {
                    simpleBusiness: 0.10,
                    consistentHistory: 0.10,
                    favorableProspects: 0.10,
                    rationalManagement: 0.08,
                    attractivePrice: 0.12,
                    highROE: 0.12,
                    lowDebt: 0.08,
                    highMargins: 0.10,
                    moat: 0.15,
                    ownerEarnings: 0.05
                };
                
                const criteriaWeights = { ...defaultWeights, ...weights };
                const scores = {};
                let totalScore = 0;
                
                // Simple Business (based on business complexity metrics)
                scores.simpleBusiness = company.businessSegments <= 3 ? 90 : 
                                        company.businessSegments <= 5 ? 70 : 50;
                
                // Consistent Operating History
                const consistencyYears = company.profitableYears || 0;
                scores.consistentHistory = Math.min(100, consistencyYears * 10);
                
                // Favorable Long-term Prospects
                const growthRate = company.expectedGrowth || 0;
                scores.favorableProspects = Math.min(100, 50 + growthRate * 2);
                
                // Rational Management
                scores.rationalManagement = company.managementScore || 75;
                
                // Attractive Price
                const peRatio = company.peRatio || 20;
                scores.attractivePrice = peRatio < 15 ? 90 :
                                         peRatio < 20 ? 70 :
                                         peRatio < 25 ? 50 : 30;
                
                // High ROE
                const roe = company.roe || 15;
                scores.highROE = Math.min(100, roe * 4);
                
                // Low Debt
                const debtToEquity = company.debtToEquity || 0.5;
                scores.lowDebt = debtToEquity < 0.3 ? 95 :
                                debtToEquity < 0.5 ? 80 :
                                debtToEquity < 1.0 ? 60 : 30;
                
                // High Profit Margins
                const profitMargin = company.profitMargin || 10;
                scores.highMargins = Math.min(100, profitMargin * 5);
                
                // Moat/Competitive Advantage
                scores.moat = company.moatScore || 70;
                
                // Owner Earnings Growth
                const earningsGrowth = company.earningsGrowth || 5;
                scores.ownerEarnings = Math.min(100, 50 + earningsGrowth * 3);
                
                // Calculate weighted total score
                Object.keys(scores).forEach(criteria => {
                    totalScore += scores[criteria] * criteriaWeights[criteria];
                });
                
                // Determine recommendation
                let recommendation = 'Hold';
                if (totalScore >= 85) recommendation = 'Strong Buy';
                else if (totalScore >= 75) recommendation = 'Buy';
                else if (totalScore >= 60) recommendation = 'Hold';
                else if (totalScore >= 45) recommendation = 'Sell';
                else recommendation = 'Strong Sell';
                
                return {
                    scores,
                    totalScore: Math.round(totalScore),
                    recommendation,
                    strengths: Object.keys(scores).filter(k => scores[k] >= 80),
                    weaknesses: Object.keys(scores).filter(k => scores[k] < 60),
                    details: Object.keys(scores).map(criteria => ({
                        criteria: criteria.replace(/([A-Z])/g, ' $1').trim(),
                        score: scores[criteria],
                        weight: criteriaWeights[criteria] * 100,
                        contribution: scores[criteria] * criteriaWeights[criteria]
                    }))
                };
            };
            
            /**
             * Calculate Dividend Safety Score
             * @param {object} dividendData - Company dividend metrics
             * @returns {object} Dividend safety analysis
             */
            const calculateDividendSafetyScore = (dividendData) => {
                const factors = {};
                let totalScore = 0;
                
                // Payout Ratio (lower is safer)
                const payoutRatio = dividendData.payoutRatio || 50;
                factors.payoutRatio = payoutRatio < 40 ? 95 :
                                      payoutRatio < 60 ? 85 :
                                      payoutRatio < 80 ? 65 : 30;
                
                // Free Cash Flow Coverage
                const fcfCoverage = dividendData.fcfCoverage || 1.5;
                factors.freeCashFlow = fcfCoverage > 2 ? 95 :
                                      fcfCoverage > 1.5 ? 85 :
                                      fcfCoverage > 1 ? 70 : 40;
                
                // Debt/Equity Ratio
                const debtEquity = dividendData.debtToEquity || 0.5;
                factors.debtEquity = debtEquity < 0.3 ? 90 :
                                    debtEquity < 0.6 ? 75 :
                                    debtEquity < 1 ? 60 : 30;
                
                // Earnings Stability
                const earningsVolatility = dividendData.earningsVolatility || 10;
                factors.earningsStability = earningsVolatility < 5 ? 95 :
                                           earningsVolatility < 10 ? 85 :
                                           earningsVolatility < 20 ? 70 : 50;
                
                // Revenue Growth
                const revenueGrowth = dividendData.revenueGrowth || 5;
                factors.revenueGrowth = revenueGrowth > 10 ? 90 :
                                       revenueGrowth > 5 ? 80 :
                                       revenueGrowth > 0 ? 70 : 50;
                
                // Dividend History (years of consistent payments)
                const dividendYears = dividendData.consecutiveDividendYears || 10;
                factors.dividendHistory = Math.min(100, dividendYears * 3);
                
                // Calculate weighted score
                const weights = {
                    payoutRatio: 0.20,
                    freeCashFlow: 0.20,
                    debtEquity: 0.15,
                    earningsStability: 0.20,
                    revenueGrowth: 0.10,
                    dividendHistory: 0.15
                };
                
                Object.keys(factors).forEach(factor => {
                    totalScore += factors[factor] * weights[factor];
                });
                
                // Determine safety rating
                let safetyRating = 'Safe';
                if (totalScore >= 85) safetyRating = 'Very Safe';
                else if (totalScore >= 70) safetyRating = 'Safe';
                else if (totalScore >= 55) safetyRating = 'Moderate';
                else if (totalScore >= 40) safetyRating = 'At Risk';
                else safetyRating = 'High Risk';
                
                return {
                    overallScore: Math.round(totalScore),
                    factors,
                    safetyRating,
                    sustainabilityYears: estimateDividendSustainability(dividendData),
                    cutProbability: 100 - totalScore,
                    keyRisks: identifyDividendRisks(factors)
                };
            };
            
            /**
             * Helper to estimate dividend sustainability
             */
            const estimateDividendSustainability = (data) => {
                const payoutRatio = data.payoutRatio || 50;
                const earningsGrowth = data.earningsGrowth || 5;
                
                if (payoutRatio >= 100) return 0;
                if (payoutRatio >= 90) return 1;
                if (earningsGrowth > 10 && payoutRatio < 60) return 10;
                if (earningsGrowth > 5 && payoutRatio < 70) return 5;
                return 3;
            };
            
            /**
             * Helper to identify dividend risks
             */
            const identifyDividendRisks = (factors) => {
                const risks = [];
                if (factors.payoutRatio < 70) risks.push('High payout ratio');
                if (factors.freeCashFlow < 70) risks.push('Weak cash flow coverage');
                if (factors.debtEquity < 60) risks.push('High debt levels');
                if (factors.earningsStability < 70) risks.push('Volatile earnings');
                return risks;
            };
            
            /**
             * Calculate Moat Strength
             * @param {object} companyData - Company competitive advantage data
             * @returns {object} Moat strength analysis
             */
            const calculateMoatStrength = (companyData) => {
                const moatFactors = {};
                
                // Brand Value
                const brandValue = companyData.brandValue || 50;
                moatFactors.brandValue = Math.min(100, brandValue * 1.5);
                
                // Switching Costs
                const switchingCosts = companyData.switchingCosts || 'medium';
                moatFactors.switchingCosts = switchingCosts === 'high' ? 90 :
                                             switchingCosts === 'medium' ? 60 : 30;
                
                // Network Effects
                const networkEffects = companyData.networkEffects || false;
                moatFactors.networkEffects = networkEffects ? 85 : 40;
                
                // Cost Advantages
                const costAdvantage = companyData.costAdvantage || 0;
                moatFactors.costAdvantage = Math.min(100, 50 + costAdvantage * 2);
                
                // Intangible Assets (patents, licenses, etc.)
                const intangibles = companyData.intangibleAssets || 50;
                moatFactors.intangibleAssets = intangibles;
                
                // Efficient Scale
                const marketShare = companyData.marketShare || 20;
                moatFactors.efficientScale = Math.min(100, marketShare * 2.5);
                
                // Calculate overall moat strength
                const moatScore = Object.values(moatFactors).reduce((sum, score) => 
                    sum + score, 0) / Object.keys(moatFactors).length;
                
                // Determine moat rating
                let moatRating = 'No Moat';
                if (moatScore >= 80) moatRating = 'Wide Moat';
                else if (moatScore >= 60) moatRating = 'Narrow Moat';
                else if (moatScore >= 40) moatRating = 'Emerging Moat';
                
                // Compare to industry average
                const industryAverage = companyData.industryAverageMoat || 50;
                const relativeStrength = moatScore - industryAverage;
                
                return {
                    moatScore: Math.round(moatScore),
                    moatRating,
                    factors: moatFactors,
                    relativeToIndustry: relativeStrength > 0 ? 'Above Average' : 'Below Average',
                    competitiveAdvantages: Object.keys(moatFactors)
                        .filter(k => moatFactors[k] >= 70)
                        .map(k => k.replace(/([A-Z])/g, ' $1').trim()),
                    vulnerabilities: Object.keys(moatFactors)
                        .filter(k => moatFactors[k] < 50)
                        .map(k => k.replace(/([A-Z])/g, ' $1').trim()),
                    sustainabilityYears: estimateMoatDurability(moatScore, companyData)
                };
            };
            
            /**
             * Helper to estimate moat durability
             */
            const estimateMoatDurability = (moatScore, data) => {
                if (moatScore >= 80 && data.innovationRate > 5) return 20;
                if (moatScore >= 70) return 15;
                if (moatScore >= 60) return 10;
                if (moatScore >= 50) return 7;
                return 5;
            };
            
            /**
             * Calculate Resilience Rating
             * @param {object} resilienceData - Company resilience metrics
             * @returns {object} Resilience analysis
             */
            const calculateResilienceRating = (resilienceData) => {
                const factors = {};
                
                // Financial Strength
                const cashRatio = resilienceData.cashRatio || 0.5;
                const debtCoverage = resilienceData.debtCoverage || 2;
                factors.financialStrength = (Math.min(100, cashRatio * 100) + 
                                            Math.min(100, debtCoverage * 25)) / 2;
                
                // Market Position
                const marketShare = resilienceData.marketShare || 15;
                const competitivePosition = resilienceData.competitiveRank || 5;
                factors.marketPosition = Math.min(100, marketShare * 3 + (10 - competitivePosition) * 5);
                
                // Adaptability
                const innovationScore = resilienceData.innovationScore || 50;
                const pivotHistory = resilienceData.successfulPivots || 0;
                factors.adaptability = Math.min(100, innovationScore + pivotHistory * 10);
                
                // Management Quality
                const managementTenure = resilienceData.avgManagementTenure || 5;
                const executionScore = resilienceData.executionScore || 70;
                factors.managementQuality = (Math.min(100, managementTenure * 10) + executionScore) / 2;
                
                // Diversification
                const revenueSources = resilienceData.revenueSources || 3;
                const geographicDiversity = resilienceData.geographicMarkets || 5;
                factors.diversification = Math.min(100, (revenueSources * 10 + geographicDiversity * 5));
                
                // Innovation Capability
                const rdSpending = resilienceData.rdAsPercentOfRevenue || 5;
                const patentCount = resilienceData.patents || 10;
                factors.innovation = Math.min(100, rdSpending * 5 + Math.log10(patentCount + 1) * 20);
                
                // Calculate overall resilience
                const resilienceScore = Object.values(factors).reduce((sum, score) => 
                    sum + score, 0) / Object.keys(factors).length;
                
                // Determine resilience rating
                let rating = 'Moderate';
                let status = 'Stable';
                
                if (resilienceScore >= 85) {
                    rating = 'Exceptional';
                    status = 'Antifragile';
                } else if (resilienceScore >= 75) {
                    rating = 'Strong';
                    status = 'Robust';
                } else if (resilienceScore >= 60) {
                    rating = 'Good';
                    status = 'Resilient';
                } else if (resilienceScore >= 45) {
                    rating = 'Moderate';
                    status = 'Stable';
                } else {
                    rating = 'Weak';
                    status = 'Vulnerable';
                }
                
                return {
                    resilienceScore: Math.round(resilienceScore),
                    rating,
                    status,
                    factors,
                    crisisReadiness: resilienceScore > 70,
                    recoveryTime: estimateRecoveryTime(resilienceScore),
                    keyStrengths: Object.keys(factors)
                        .filter(k => factors[k] >= 75)
                        .map(k => k.replace(/([A-Z])/g, ' $1').trim()),
                    improvements: Object.keys(factors)
                        .filter(k => factors[k] < 60)
                        .map(k => k.replace(/([A-Z])/g, ' $1').trim())
                };
            };
            
            /**
             * Helper to estimate recovery time from crisis
             */
            const estimateRecoveryTime = (resilienceScore) => {
                if (resilienceScore >= 80) return '3-6 months';
                if (resilienceScore >= 70) return '6-12 months';
                if (resilienceScore >= 60) return '12-18 months';
                if (resilienceScore >= 50) return '18-24 months';
                return '24+ months';
            };
            
            
            // ============================================
            // Caching Layer (React Query-Inspired)
            // ============================================
            
            /**
             * CacheManager - React Query-inspired caching system
             * 
             * Features:
             * - Query key-based caching
             * - Stale-while-revalidate pattern
             * - Automatic garbage collection
             * - Request deduplication
             * - Cache invalidation on mutations
             * - Background refetching
             * 
             * Inspired by React Query patterns from the TypeScript implementation
             */
            const CacheManager = (() => {
                // Cache storage
                const cache = new Map();
                const querySubscribers = new Map();
                const activeRequests = new Map();
                const cacheTimers = new Map();
                
                // Default configuration (matching React Query defaults)
                const defaultConfig = {
                    staleTime: 5 * 60 * 1000,      // 5 minutes - how long data is fresh
                    gcTime: 10 * 60 * 1000,         // 10 minutes - garbage collection time
                    retryCount: 3,                   // Number of retry attempts
                    retryDelay: 1000,                // Base retry delay
                    refetchOnWindowFocus: true,     // Refetch when window gains focus
                    refetchOnReconnect: true,        // Refetch on network reconnect
                    backgroundRefetchInterval: null  // Background refetch interval (null = disabled)
                };
                
                /**
                 * Generate cache key from query key array or string
                 * @param {Array|string} queryKey - Query key
                 * @returns {string} Serialized cache key
                 */
                const getCacheKey = (queryKey) => {
                    if (typeof queryKey === 'string') return queryKey;
                    if (Array.isArray(queryKey)) return JSON.stringify(queryKey);
                    return JSON.stringify([queryKey]);
                };
                
                /**
                 * Check if cached data is stale
                 * @param {object} entry - Cache entry
                 * @param {number} staleTime - Stale time in ms
                 * @returns {boolean} Whether data is stale
                 */
                const isStale = (entry, staleTime = defaultConfig.staleTime) => {
                    if (!entry) return true;
                    const age = Date.now() - entry.timestamp;
                    return age > staleTime;
                };
                
                /**
                 * Check if cache should be garbage collected
                 * @param {object} entry - Cache entry
                 * @param {number} gcTime - Garbage collection time in ms
                 * @returns {boolean} Whether to garbage collect
                 */
                const shouldGarbageCollect = (entry, gcTime = defaultConfig.gcTime) => {
                    if (!entry) return true;
                    const age = Date.now() - entry.lastAccessed;
                    return age > gcTime && entry.subscribers === 0;
                };
                
                /**
                 * Get cached data with stale-while-revalidate pattern
                 * @param {Array|string} queryKey - Query key
                 * @param {Function} queryFn - Function to fetch data
                 * @param {object} options - Query options
                 * @returns {Promise} Cached or fresh data
                 */
                const get = async (queryKey, queryFn, options = {}) => {
                    const key = getCacheKey(queryKey);
                    const config = { ...defaultConfig, ...options };
                    
                    // Check cache
                    const cached = cache.get(key);
                    
                    // Update last accessed time
                    if (cached) {
                        cached.lastAccessed = Date.now();
                    }
                    
                    // Return fresh cached data immediately
                    if (cached && !isStale(cached, config.staleTime)) {
                        return { 
                            data: cached.data, 
                            error: null, 
                            isStale: false,
                            isFetching: false,
                            isFromCache: true
                        };
                    }
                    
                    // Check if there's already an active request (deduplication)
                    if (activeRequests.has(key)) {
                        const activePromise = activeRequests.get(key);
                        return activePromise;
                    }
                    
                    // Stale-while-revalidate: Return stale data immediately while fetching
                    if (cached && isStale(cached, config.staleTime)) {
                        // Start background refetch
                        const refetchPromise = fetchWithRetry(queryFn, config)
                            .then(data => {
                                set(queryKey, data);
                                notifySubscribers(key, { data, error: null, isStale: false });
                                return { data, error: null, isStale: false, isFetching: false };
                            })
                            .catch(error => {
                                // Keep stale data on error
                                notifySubscribers(key, { data: cached.data, error, isStale: true });
                                return { data: cached.data, error, isStale: true, isFetching: false };
                            })
                            .finally(() => {
                                activeRequests.delete(key);
                            });
                        
                        activeRequests.set(key, refetchPromise);
                        
                        // Return stale data immediately
                        return { 
                            data: cached.data, 
                            error: null, 
                            isStale: true, 
                            isFetching: true,
                            isFromCache: true
                        };
                    }
                    
                    // No cache or expired - fetch fresh data
                    const fetchPromise = fetchWithRetry(queryFn, config)
                        .then(data => {
                            set(queryKey, data);
                            notifySubscribers(key, { data, error: null, isStale: false });
                            return { data, error: null, isStale: false, isFetching: false };
                        })
                        .catch(error => {
                            notifySubscribers(key, { data: null, error, isStale: false });
                            throw error;
                        })
                        .finally(() => {
                            activeRequests.delete(key);
                        });
                    
                    activeRequests.set(key, fetchPromise);
                    return fetchPromise;
                };
                
                /**
                 * Fetch with retry logic
                 * @param {Function} queryFn - Query function
                 * @param {object} config - Configuration
                 * @returns {Promise} Query result
                 */
                const fetchWithRetry = async (queryFn, config) => {
                    let lastError;
                    
                    for (let attempt = 0; attempt <= config.retryCount; attempt++) {
                        try {
                            const result = await queryFn();
                            return result;
                        } catch (error) {
                            lastError = error;
                            
                            // Don't retry on 4xx errors
                            if (error.response?.status >= 400 && error.response?.status < 500) {
                                throw error;
                            }
                            
                            // Wait before retry with exponential backoff
                            if (attempt < config.retryCount) {
                                const delay = Math.min(
                                    config.retryDelay * Math.pow(2, attempt),
                                    30000
                                );
                                await new Promise(resolve => setTimeout(resolve, delay));
                            }
                        }
                    }
                    
                    throw lastError;
                };
                
                /**
                 * Set data in cache
                 * @param {Array|string} queryKey - Query key
                 * @param {any} data - Data to cache
                 * @param {object} options - Cache options
                 */
                const set = (queryKey, data, options = {}) => {
                    const key = getCacheKey(queryKey);
                    const config = { ...defaultConfig, ...options };
                    
                    // Clear existing garbage collection timer
                    if (cacheTimers.has(key)) {
                        clearTimeout(cacheTimers.get(key));
                    }
                    
                    // Store in cache
                    cache.set(key, {
                        data,
                        timestamp: Date.now(),
                        lastAccessed: Date.now(),
                        subscribers: querySubscribers.get(key)?.size || 0
                    });
                    
                    // Schedule garbage collection
                    const gcTimer = setTimeout(() => {
                        const entry = cache.get(key);
                        if (entry && shouldGarbageCollect(entry, config.gcTime)) {
                            cache.delete(key);
                            cacheTimers.delete(key);
                        }
                    }, config.gcTime);
                    
                    cacheTimers.set(key, gcTimer);
                };
                
                /**
                 * Invalidate cache entries
                 * @param {Array|string|Function} queryKey - Query key or predicate
                 */
                const invalidate = (queryKey) => {
                    if (typeof queryKey === 'function') {
                        // Invalidate by predicate
                        for (const [key, entry] of cache.entries()) {
                            if (queryKey(key, entry.data)) {
                                cache.delete(key);
                                notifySubscribers(key, { invalidated: true });
                            }
                        }
                    } else {
                        // Invalidate by key
                        const key = getCacheKey(queryKey);
                        
                        // Support partial matching for array keys
                        if (Array.isArray(queryKey)) {
                            const prefix = JSON.stringify(queryKey);
                            for (const cacheKey of cache.keys()) {
                                if (cacheKey.startsWith(prefix.slice(0, -1))) {
                                    cache.delete(cacheKey);
                                    notifySubscribers(cacheKey, { invalidated: true });
                                }
                            }
                        } else {
                            cache.delete(key);
                            notifySubscribers(key, { invalidated: true });
                        }
                    }
                };
                
                /**
                 * Clear entire cache
                 */
                const clear = () => {
                    cache.clear();
                    activeRequests.clear();
                    
                    // Clear all timers
                    for (const timer of cacheTimers.values()) {
                        clearTimeout(timer);
                    }
                    cacheTimers.clear();
                    
                    // Notify all subscribers
                    for (const key of querySubscribers.keys()) {
                        notifySubscribers(key, { invalidated: true });
                    }
                };
                
                /**
                 * Subscribe to cache updates
                 * @param {Array|string} queryKey - Query key
                 * @param {Function} callback - Callback function
                 * @returns {Function} Unsubscribe function
                 */
                const subscribe = (queryKey, callback) => {
                    const key = getCacheKey(queryKey);
                    
                    if (!querySubscribers.has(key)) {
                        querySubscribers.set(key, new Set());
                    }
                    
                    querySubscribers.get(key).add(callback);
                    
                    // Update subscriber count
                    const entry = cache.get(key);
                    if (entry) {
                        entry.subscribers = querySubscribers.get(key).size;
                    }
                    
                    // Return unsubscribe function
                    return () => {
                        const subscribers = querySubscribers.get(key);
                        if (subscribers) {
                            subscribers.delete(callback);
                            if (subscribers.size === 0) {
                                querySubscribers.delete(key);
                            }
                            
                            // Update subscriber count
                            const entry = cache.get(key);
                            if (entry) {
                                entry.subscribers = subscribers.size;
                            }
                        }
                    };
                };
                
                /**
                 * Notify subscribers of cache updates
                 * @param {string} key - Cache key
                 * @param {object} update - Update data
                 */
                const notifySubscribers = (key, update) => {
                    const subscribers = querySubscribers.get(key);
                    if (subscribers) {
                        subscribers.forEach(callback => {
                            try {
                                callback(update);
                            } catch (error) {
                                console.error('Error in cache subscriber:', error);
                            }
                        });
                    }
                };
                
                /**
                 * Prefetch data into cache
                 * @param {Array|string} queryKey - Query key
                 * @param {Function} queryFn - Query function
                 * @param {object} options - Options
                 */
                const prefetch = async (queryKey, queryFn, options = {}) => {
                    const key = getCacheKey(queryKey);
                    const cached = cache.get(key);
                    
                    // Only prefetch if not cached or stale
                    if (!cached || isStale(cached, options.staleTime)) {
                        try {
                            const data = await queryFn();
                            set(queryKey, data, options);
                        } catch (error) {
                            console.error('Prefetch error:', error);
                        }
                    }
                };
                
                /**
                 * Get cache statistics
                 * @returns {object} Cache statistics
                 */
                const getStats = () => {
                    const entries = Array.from(cache.entries());
                    const now = Date.now();
                    
                    return {
                        size: cache.size,
                        activeRequests: activeRequests.size,
                        subscribers: querySubscribers.size,
                        entries: entries.map(([key, entry]) => ({
                            key,
                            age: now - entry.timestamp,
                            lastAccessed: now - entry.lastAccessed,
                            isStale: isStale(entry),
                            subscribers: entry.subscribers
                        }))
                    };
                };
                
                // Setup window focus refetching
                if (typeof window !== 'undefined' && defaultConfig.refetchOnWindowFocus) {
                    window.addEventListener('focus', () => {
                        // Refetch all queries with subscribers
                        for (const [key, subscribers] of querySubscribers.entries()) {
                            if (subscribers.size > 0) {
                                const cached = cache.get(key);
                                if (cached && isStale(cached)) {
                                    // Mark for refetch
                                    cached.timestamp = 0;
                                }
                            }
                        }
                    });
                }
                
                // Setup online/offline handling
                if (typeof window !== 'undefined' && defaultConfig.refetchOnReconnect) {
                    window.addEventListener('online', () => {
                        // Trigger refetch for stale queries
                        for (const [key, entry] of cache.entries()) {
                            if (isStale(entry)) {
                                notifySubscribers(key, { refetch: true });
                            }
                        }
                    });
                }
                
                return {
                    get,
                    set,
                    invalidate,
                    clear,
                    subscribe,
                    prefetch,
                    getStats,
                    isStale,
                    config: defaultConfig
                };
            })();

            // ============================================
            // ERROR HANDLING UTILITIES
            // ============================================
            
            /**
             * Error Classification and User-Friendly Messaging
             * Maps technical errors to helpful user messages
             */
            const ErrorHandler = {
                /**
                 * Map error codes to user-friendly messages
                 */
                errorMessages: {
                    400: "There was an issue with your request. Please check your input and try again.",
                    401: "Your session has expired. Please log in again to continue.",
                    403: "You don't have permission to access this resource.",
                    404: "The requested data could not be found. It may have been moved or deleted.",
                    408: "The request took too long. Please check your connection and try again.",
                    429: "Too many requests. Please wait a moment and try again.",
                    500: "We're experiencing a server issue. Please try again in a few moments.",
                    502: "Unable to connect to the server. Please check your connection.",
                    503: "The service is temporarily unavailable. Please try again later.",
                    504: "The server took too long to respond. Please try again.",
                    
                    // Network errors
                    'NETWORK_ERROR': "Unable to connect to the server. Please check your internet connection.",
                    'TIMEOUT': "The request timed out. Please try again.",
                    'UNKNOWN_ERROR': "An unexpected error occurred. Please try again.",
                    
                    // Application-specific errors
                    'INVALID_PORTFOLIO': "The selected portfolio could not be found.",
                    'INSUFFICIENT_DATA': "Not enough data available for this analysis.",
                    'CALCULATION_ERROR': "Unable to complete the calculation. Please try again.",
                    'AUTH_EXPIRED': "Your authentication has expired. Please log in again.",
                    'RATE_LIMIT': "You've made too many requests. Please wait a moment.",
                    'VALIDATION_ERROR': "Please check your input and try again.",
                    'CONNECTION_LOST': "Connection to the server was lost. Attempting to reconnect..."
                },
                
                /**
                 * Classify error type for appropriate handling
                 */
                classifyError: (error) => {
                    // Check if it's a network error
                    if (!window.navigator.onLine) {
                        return {
                            type: 'network',
                            severity: 'warning',
                            message: ErrorHandler.errorMessages['NETWORK_ERROR'],
                            canRetry: true
                        };
                    }
                    
                    // Check for response status codes
                    if (error.response) {
                        const status = error.response.status;
                        const message = ErrorHandler.errorMessages[status] || 
                                       error.response.data?.detail || 
                                       error.response.data?.message || 
                                       'An error occurred. Please try again.';
                        
                        return {
                            type: status >= 500 ? 'server' : 'client',
                            severity: status >= 500 ? 'error' : 'warning',
                            status,
                            message,
                            canRetry: status >= 500 || status === 408 || status === 429,
                            details: error.response.data
                        };
                    }
                    
                    // Check for request errors (no response received)
                    if (error.request) {
                        return {
                            type: 'network',
                            severity: 'error',
                            message: ErrorHandler.errorMessages['NETWORK_ERROR'],
                            canRetry: true
                        };
                    }
                    
                    // Check for timeout errors
                    if (error.code === 'ECONNABORTED' || error.message.includes('timeout')) {
                        return {
                            type: 'timeout',
                            severity: 'warning',
                            message: ErrorHandler.errorMessages['TIMEOUT'],
                            canRetry: true
                        };
                    }
                    
                    // Default to unknown error
                    return {
                        type: 'unknown',
                        severity: 'error',
                        message: error.message || ErrorHandler.errorMessages['UNKNOWN_ERROR'],
                        canRetry: true
                    };
                },
                
                /**
                 * Get actionable suggestions based on error type
                 */
                getSuggestions: (errorInfo) => {
                    const suggestions = [];
                    
                    switch (errorInfo.type) {
                        case 'network':
                            suggestions.push('Check your internet connection');
                            suggestions.push('Try refreshing the page');
                            suggestions.push('Check if you are behind a firewall or VPN');
                            break;
                        case 'server':
                            suggestions.push('Wait a few moments and try again');
                            suggestions.push('If the problem persists, contact support');
                            break;
                        case 'client':
                            if (errorInfo.status === 401) {
                                suggestions.push('Click here to log in again');
                            } else if (errorInfo.status === 403) {
                                suggestions.push('Contact your administrator for access');
                            } else if (errorInfo.status === 429) {
                                suggestions.push('Wait a few seconds before retrying');
                            }
                            break;
                        case 'timeout':
                            suggestions.push('Check your internet connection speed');
                            suggestions.push('Try again with a smaller data range');
                            break;
                    }
                    
                    return suggestions;
                },
                
                /**
                 * Log error for debugging (in development mode)
                 */
                logError: (error, context = {}) => {
                    if (console.group) {
                        console.group('%c Error Details', 'color: #ef4444; font-weight: bold');
                        console.error('Error:', error);
                        console.log('Context:', context);
                        console.log('Stack:', error.stack);
                        console.log('Timestamp:', new Date().toISOString());
                        console.groupEnd();
                    } else {
                        console.error('Error occurred:', error, context);
                    }
                }
            };
            
            /**
             * Form Validation Utilities
             */
            const FormValidator = {
                /**
                 * Validate email format
                 */
                validateEmail: (email) => {
                    const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                    if (!email) return { valid: false, message: 'Email is required' };
                    if (!re.test(email)) return { valid: false, message: 'Please enter a valid email address' };
                    return { valid: true };
                },
                
                /**
                 * Validate password strength
                 */
                validatePassword: (password) => {
                    if (!password) return { valid: false, message: 'Password is required' };
                    if (password.length < 8) return { valid: false, message: 'Password must be at least 8 characters' };
                    return { valid: true };
                },
                
                /**
                 * Validate required field
                 */
                validateRequired: (value, fieldName) => {
                    if (!value || value.toString().trim() === '') {
                        return { valid: false, message: `${fieldName} is required` };
                    }
                    return { valid: true };
                },
                
                /**
                 * Validate number range
                 */
                validateRange: (value, min, max, fieldName) => {
                    const num = parseFloat(value);
                    if (isNaN(num)) return { valid: false, message: `${fieldName} must be a number` };
                    if (num < min) return { valid: false, message: `${fieldName} must be at least ${min}` };
                    if (num > max) return { valid: false, message: `${fieldName} must be at most ${max}` };
                    return { valid: true };
                }
            };
            
            // ============================================
            // ERROR BOUNDARY COMPONENT
            // ============================================
            
            /**
             * ErrorBoundary - Catches JavaScript errors in component tree
             * Provides fallback UI and recovery options
             */
            class ErrorBoundary extends React.Component {
                constructor(props) {
                    super(props);
                    this.state = {
                        hasError: false,
                        error: null,
                        errorInfo: null,
                        errorCount: 0,
                        isAutoRecovering: false,
                        autoRecoveryMessage: null
                    };
                    this.autoRecoveryTimer = null;
                }
                
                static getDerivedStateFromError(error) {
                    // Update state to render error UI
                    return { hasError: true };
                }
                
                componentDidCatch(error, errorInfo) {
                    // Log error details for debugging
                    ErrorHandler.logError(error, { 
                        componentStack: errorInfo.componentStack,
                        props: this.props 
                    });
                    
                    // Check for portfolio_id error and auto-recover
                    const errorMessage = error?.toString() || '';
                    const errorStack = error?.stack || '';
                    const componentStack = errorInfo?.componentStack || '';
                    
                    if (errorMessage.includes('portfolio_id') || 
                        errorStack.includes('portfolio_id') ||
                        componentStack.includes('portfolio_id')) {
                        
                        console.log('[ErrorBoundary] Detected portfolio_id error - initiating auto-recovery');
                        console.log('[ErrorBoundary] Error details:', {
                            message: errorMessage,
                            stack: errorStack.slice(0, 500),
                            component: componentStack.slice(0, 500)
                        });
                        
                        // Set auto-recovery state
                        this.setState({
                            error,
                            errorInfo,
                            isAutoRecovering: true,
                            autoRecoveryMessage: 'Refreshing portfolio data...',
                            errorCount: this.state.errorCount + 1
                        });
                        
                        // Clear any existing timer
                        if (this.autoRecoveryTimer) {
                            clearTimeout(this.autoRecoveryTimer);
                        }
                        
                        // Auto-reload after 2 seconds
                        this.autoRecoveryTimer = setTimeout(() => {
                            console.log('[ErrorBoundary] Auto-recovery: Reloading page');
                            window.location.reload();
                        }, 2000);
                        
                    } else {
                        // Regular error handling for non-portfolio_id errors
                        console.log('[ErrorBoundary] Regular error caught:', errorMessage);
                        
                        // Update state with error details
                        this.setState(prevState => ({
                            error,
                            errorInfo,
                            errorCount: prevState.errorCount + 1,
                            isAutoRecovering: false,
                            autoRecoveryMessage: null
                        }));
                    }
                    
                    // Report to error tracking service (if configured)
                    if (window.errorReporter) {
                        window.errorReporter.report(error, errorInfo);
                    }
                }
                
                componentWillUnmount() {
                    // Clean up timer on unmount
                    if (this.autoRecoveryTimer) {
                        clearTimeout(this.autoRecoveryTimer);
                    }
                }
                
                handleReset = () => {
                    // Clear any auto-recovery timer
                    if (this.autoRecoveryTimer) {
                        clearTimeout(this.autoRecoveryTimer);
                        this.autoRecoveryTimer = null;
                    }
                    
                    // Reset error boundary state
                    this.setState({
                        hasError: false,
                        error: null,
                        errorInfo: null,
                        isAutoRecovering: false,
                        autoRecoveryMessage: null
                    });
                    
                    // Optionally reload the page if errors persist
                    if (this.state.errorCount > 3) {
                        window.location.reload();
                    }
                };
                
                render() {
                    if (this.state.hasError) {
                        // Check if auto-recovering
                        if (this.state.isAutoRecovering) {
                            console.log('[ErrorBoundary] Rendering auto-recovery UI');
                            return e('div', { className: 'error-boundary-fallback' },
                                e('div', { className: 'error-container' },
                                    e('div', { className: 'error-icon' }, ''),
                                    e('h2', { className: 'error-title' }, 'Auto-Recovery in Progress'),
                                    e('p', { className: 'error-description' }, 
                                        this.state.autoRecoveryMessage || 'Refreshing portfolio data...'
                                    ),
                                    e('div', { className: 'loading' },
                                        e('div', { className: 'spinner' })
                                    ),
                                    e('p', { 
                                        style: { 
                                            marginTop: '1rem', 
                                            fontSize: '0.875rem', 
                                            color: 'var(--text-secondary)' 
                                        } 
                                    }, 'Page will reload automatically in a moment...')
                                )
                            );
                        }
                        
                        // Render regular error fallback UI
                        return e('div', { className: 'error-boundary-fallback' },
                            e('div', { className: 'error-container' },
                                e('div', { className: 'error-icon' }, ''),
                                e('h2', { className: 'error-title' }, 'Something went wrong'),
                                e('p', { className: 'error-description' }, 
                                    'An unexpected error occurred. The application has logged this error and it will be reviewed.'
                                ),
                                
                                // Show error details in development
                                (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') && 
                                this.state.error && e('details', { className: 'error-details' },
                                    e('summary', null, 'Error Details (Development Only)'),
                                    e('pre', { className: 'error-stack' }, 
                                        this.state.error.toString(),
                                        '\n\n',
                                        this.state.errorInfo?.componentStack
                                    )
                                ),
                                
                                e('div', { className: 'error-actions' },
                                    e('button', { 
                                        className: 'btn btn-primary',
                                        onClick: this.handleReset
                                    }, 'Try Again'),
                                    e('button', { 
                                        className: 'btn',
                                        onClick: () => window.location.reload()
                                    }, 'Reload Page')
                                )
                            )
                        );
                    }
                    
                    return this.props.children;
                }
            }
            
            // ============================================
            // DATA PROVENANCE COMPONENTS
            // ============================================
            // Navigation Structure with All 52 Capabilities
            // ============================================
            
            const navigationStructure = [
                {
                    section: 'Portfolio',
                    items: [
                        { id: 'dashboard', label: 'Dashboard', path: '/dashboard' },
                        { id: 'holdings', label: 'Holdings', path: '/holdings' },
                        { id: 'transactions', label: 'Transactions', path: '/transactions' },
                        { id: 'performance', label: 'Performance', path: '/performance' },
                        { id: 'corporate-actions', label: 'Corporate Actions', path: '/corporate-actions' }
                    ]
                },
                {
                    section: 'Analysis',
                    items: [
                        { id: 'macro-cycles', label: 'Macro Cycles', path: '/macro-cycles' },
                        { id: 'scenarios', label: 'Scenarios', path: '/scenarios' },
                        { id: 'risk', label: 'Risk Analytics', path: '/risk' },
                        { id: 'attribution', label: 'Attribution', path: '/attribution' }
                    ]
                },
                {
                    section: 'Intelligence',
                    items: [
                        { id: 'optimizer', label: 'Optimizer', path: '/optimizer' },
                        { id: 'ratings', label: 'Ratings', path: '/ratings' },
                        { id: 'ai-insights', label: 'AI Insights', path: '/ai-insights' },
                        { id: 'ai-assistant', label: 'AI Assistant', path: '/ai-assistant' },
                        { id: 'market-data', label: 'Market Data', path: '/market-data' }
                    ]
                },
                {
                    section: 'Operations',
                    items: [
                        { id: 'alerts', label: 'Alerts', path: '/alerts' },
                        { id: 'reports', label: 'Reports', path: '/reports' },
                        { id: 'settings', label: 'Settings', path: '/settings' }
                    ]
                }
            ];
            
            // ============================================
            // Component: Main Application
            // ============================================
            
            function App() {
                const [isAuthenticated, setIsAuthenticated] = useState(!!TokenManager.getToken());
                const [currentPage, setCurrentPage] = useState('dashboard');
                const [user, setUser] = useState(TokenManager.getUser());
                const [sidebarOpen, setSidebarOpen] = useState(false);
                
                useEffect(() => {
                    // Check if user is authenticated on mount
                    const token = TokenManager.getToken();
                    const savedUser = TokenManager.getUser();
                    if (token && savedUser) {
                        setIsAuthenticated(true);
                        setUser(savedUser);
                    }
                    
                    // Listen for navigation events
                    const handleNavigate = (event) => {
                        if (event.detail && event.detail.page) {
                            setCurrentPage(event.detail.page);
                        }
                    };
                    window.addEventListener('navigate', handleNavigate);
                    
                    return () => {
                        window.removeEventListener('navigate', handleNavigate);
                    };
                }, []);
                
                const handleLogin = (userData) => {
                    setIsAuthenticated(true);
                    setUser(userData);
                    setCurrentPage('dashboard');
                };
                
                const handleLogout = () => {
                    TokenManager.removeToken();
                    TokenManager.removeUser();
                    // Clear portfolio selection from localStorage
                    localStorage.removeItem('selectedPortfolioId');
                    setIsAuthenticated(false);
                    setUser(null);
                    setCurrentPage('dashboard');
                };
                
                const toggleSidebar = () => {
                    setSidebarOpen(!sidebarOpen);
                };
                
                const renderPage = () => {
                    switch(currentPage) {
                        case 'dashboard':
                            return e(DashboardPage);
                        case 'holdings':
                            return e(HoldingsPage);
                        case 'security-detail':
                            return e(SecurityDetailPage);
                        case 'transactions':
                            return e(TransactionsPage);
                        case 'performance':
                            return e(PerformancePage);
                        case 'macro-cycles':
                            return e(MacroCyclesPage);
                        case 'scenarios':
                            return e(ScenariosPage);
                        case 'risk':
                            return e(RiskPage);
                        case 'attribution':
                            return e(AttributionPage);
                        case 'optimizer':
                            return e(OptimizerPage);
                        case 'ratings':
                            return e(RatingsPage);
                        case 'ai-insights':
                            return e(AIInsightsPage);
                        case 'ai-assistant':
                            return e(AIAssistantPage);
                        case 'alerts':
                            return e(AlertsPage);
                        case 'reports':
                            return e(ReportsPage);
                        case 'corporate-actions':
                            return e(CorporateActionsPage);
                        case 'market-data':
                            return e(MarketDataPage);
                        case 'settings':
                            return e(SettingsPage);
                        default:
                            return e('div', null, 'Page not found');
                    }
                };
                
                if (!isAuthenticated) {
                    return e(LoginPage, { onLogin: handleLogin });
                }
                
                return e(UserContextProvider, { user },
                    e('div', { className: 'dashboard' },
                        // Sidebar
                        e('aside', { className: `sidebar ${sidebarOpen ? 'open' : ''}` },
                        e('div', { className: 'sidebar-header' },
                            e('div', { className: 'sidebar-brand' }, 'DawsOS')
                        ),
                        e('nav', { className: 'sidebar-nav' },
                            navigationStructure.map(section =>
                                e('div', { key: section.section, className: 'nav-section' },
                                    e('div', { className: 'nav-section-title' }, section.section),
                                    section.items.map(item =>
                                        e('button', {
                                            key: item.id,
                                            className: `nav-item ${currentPage === item.id ? 'active' : ''}`,
                                            onClick: () => {
                                                setCurrentPage(item.id);
                                                setSidebarOpen(false);
                                            }
                                        }, item.label)
                                    )
                                )
                            )
                        )
                    ),
                    
                    // Main Content
                    e('div', { className: `main-wrapper ${!sidebarOpen ? '' : 'expanded'}` },
                        // Header
                        e('header', { className: 'header-bar' },
                            e('div', { className: 'header-left' },
                                e('button', { 
                                    className: 'menu-toggle',
                                    onClick: toggleSidebar
                                }, ''),
                                e('div', { className: 'breadcrumb' },
                                    e('span', null, 'DawsOS'),
                                    e('span', { className: 'breadcrumb-separator' }, '/'),
                                    e('span', { className: 'breadcrumb-current' }, 
                                        navigationStructure.flatMap(s => s.items)
                                            .find(i => i.id === currentPage)?.label || 'Dashboard')
                                )
                            ),
                            e('div', { className: 'header-right' },
                                e(PortfolioSelector),
                                e('div', { className: 'user-info' }, user?.email || 'User'),
                                e('button', { 
                                    className: 'btn-logout',
                                    onClick: handleLogout
                                }, 'Logout')
                            )
                        ),
                        
                        // Page Content
                        e('main', { className: 'page-content' },
                            renderPage()
                        )
                    )
                    )
                );
            }

            // Wrap the App with ErrorBoundary and render the application
            ReactDOM.render(
                e(ErrorBoundary, null, e(App)),
                document.getElementById('root')
            );
        }
        
        // Start the initialization when the DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            // DOM is already loaded
            initializeApp();
        }
    </script>
</body>
</html>