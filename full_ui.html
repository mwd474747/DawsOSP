<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DawsOS Portfolio Intelligence Platform</title>
    
    <!-- Prevent aggressive caching during development -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <!-- React UMD builds -->
    <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/axios@1.6.2/dist/axios.min.js"></script>
    <!-- Chart.js for visualizations -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <!-- Core Systems (MUST load FIRST - before all other modules) -->
    <script src="frontend/cache-manager.js?v=20251107.2"></script>
    <script src="frontend/error-handler.js?v=20251107.2"></script>
    <script src="frontend/form-validator.js?v=20251107.2"></script>

    <!-- API Client Module -->
    <script src="frontend/api-client.js?v=20251107.3"></script>

    <!-- Utility Functions Module (can now use CacheManager) -->
    <script src="frontend/utils.js?v=20251107.2"></script>
    <!-- Panel Components Module -->
    <script src="frontend/panels.js?v=20251107.2"></script>
    <!-- Context System Module (MUST load before pattern-system and pages) -->
    <script src="frontend/context.js?v=20251107.2"></script>
    <!-- Pattern System Module (depends on CacheManager, context, utils, panels) -->
    <script src="frontend/pattern-system.js?v=20251107.2"></script>
    <!-- Page Components Module (depends on ALL modules above) -->
    <script src="frontend/pages.js?v=20251107.2"></script>

    <!-- Professional Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@300;400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="frontend/styles.css">
</head>
<body>
    <div id="root"></div>
    
    <script>
        // Check if React is loaded
        if (typeof React === 'undefined' || typeof ReactDOM === 'undefined') {
            document.getElementById('root').innerHTML = '<div style="padding: 2rem; text-align: center;">Loading React framework...</div>';
            setTimeout(() => location.reload(), 2000);
        } else {
            // Initialize the application
            const { useState, useEffect, useCallback, useRef } = React;
            const e = React.createElement;
            
            // ============================================
            // API Client is now loaded from frontend/api-client.js
            // All API functionality (TokenManager, apiClient, etc.)
            // is available globally from the external module
            // ============================================

            // ============================================
            // Import Core Systems from Modules
            // ============================================
            // Verify core systems loaded successfully
            if (!DawsOS.CacheManager || !DawsOS.ErrorHandler || !DawsOS.FormValidator) {
                console.error('[App] Critical modules not loaded!', {
                    CacheManager: !!DawsOS.CacheManager,
                    ErrorHandler: !!DawsOS.ErrorHandler,
                    FormValidator: !!DawsOS.FormValidator
                });
                document.getElementById('root').innerHTML =
                    '<div style="padding: 2rem; text-align: center; color: #ef4444;">' +
                    '<h2>Module Loading Error</h2>' +
                    '<p>Critical modules failed to load. Please refresh the page.</p>' +
                    '</div>';
                throw new Error('Critical modules (CacheManager, ErrorHandler, FormValidator) not loaded!');
            }

            // Import core systems
            const CacheManager = DawsOS.CacheManager;
            const ErrorHandler = DawsOS.ErrorHandler;
            const FormValidator = DawsOS.FormValidator;

            console.log('[App] Core systems loaded successfully', {
                CacheManager: !!CacheManager,
                ErrorHandler: !!ErrorHandler,
                FormValidator: !!FormValidator
            });

            // ============================================
            // CENTRALIZED MODULE LOADER WITH VALIDATION
            // ============================================

            /**
             * Validate that all required modules and their exports are available
             * Fail fast with clear error messages if any dependencies are missing
             */
            function validateModules() {
                const requiredModules = {
                    // ============================================
                    // PHASE 2 NAMESPACE STRUCTURE
                    // ============================================

                    // Core Infrastructure (Phase 2.1)
                    'DawsOS.Core.API': [
                        'request', 'get', 'post', 'put', 'delete', 'TokenManager', 'retryConfig'
                    ],
                    'DawsOS.Core.Auth': ['getCurrentPortfolioId'],
                    'DawsOS.Core.Errors': ['handleApiError'],

                    // Pattern System (Phase 2.3)
                    'DawsOS.Patterns.Renderer': ['render', 'PatternRenderer'],
                    'DawsOS.Patterns.Registry': ['patterns', 'get', 'list', 'validate'],
                    'DawsOS.Patterns.Helpers': ['getDataByPath', 'queryKeys', 'queryHelpers', 'PanelRenderer'],

                    // UI Components (Phase 2.2)
                    'DawsOS.UI.Primitives': [
                        'LoadingSpinner', 'ErrorMessage', 'EmptyState', 'RetryableError',
                        'DataBadge', 'FormField', 'NetworkStatusIndicator'
                    ],

                    // Utils (Phase 2.2)
                    'DawsOS.Utils.Formatting': [
                        'currency', 'percentage', 'number', 'date', 'value', 'getColorClass'
                    ],
                    'DawsOS.Utils.Hooks': ['useCachedQuery', 'useCachedMutation'],
                    'DawsOS.Utils.Data': ['getDataSourceFromResponse', 'withDataProvenance', 'ProvenanceWarningBanner'],

                    // Panels
                    'DawsOS.Panels': [
                        'MetricsGridPanel', 'TablePanel', 'LineChartPanel', 'NewsListPanel',
                        'PieChartPanel', 'DonutChartPanel', 'ScorecardPanel', 'BarChartPanel',
                        'ActionCardsPanel', 'CycleCardPanel', 'DualListPanel', 'ReportViewerPanel'
                    ],

                    // Pages
                    'DawsOS.Pages': [
                        'LoginPage', 'DashboardPage', 'DashboardPageLegacy', 'HoldingsPage',
                        'SecurityDetailPage', 'TransactionsPage', 'PerformancePage',
                        'MacroCyclesPage', 'ScenariosPage', 'RiskPage', 'AttributionPage',
                        'OptimizerPage', 'RatingsPage', 'AIInsightsPage', 'AIAssistantPage',
                        'AlertsPage', 'ReportsPage', 'CorporateActionsPage', 'MarketDataPage',
                        'SettingsPage'
                    ],

                    // Context
                    'DawsOS.Context': [
                        'UserContext', 'UserContextProvider', 'useUserContext', 'PortfolioSelector'
                    ],

                    // Other modules
                    'DawsOS.CacheManager': [],
                    'DawsOS.FormValidator': [],
                    'DawsOS.ErrorHandler': []
                };

                const errors = [];
                const warnings = [];

                // Check each module and its exports
                for (const [modulePath, exports] of Object.entries(requiredModules)) {
                    const moduleObj = modulePath.split('.').reduce((obj, key) => obj?.[key], window);

                    if (!moduleObj) {
                        errors.push(`Module ${modulePath} not found. Check script load order.`);
                        continue;
                    }

                    // Check each export
                    for (const exportName of exports) {
                        if (typeof moduleObj[exportName] === 'undefined') {
                            errors.push(`${modulePath}.${exportName} is undefined`);
                        } else if (moduleObj[exportName] === null) {
                            warnings.push(`${modulePath}.${exportName} is null`);
                        }
                    }
                }

                return { errors, warnings };
            }

            // Validate modules before proceeding
            const validation = validateModules();

            if (validation.errors.length > 0) {
                console.error('[App] Module validation failed!', validation.errors);
                document.getElementById('root').innerHTML =
                    '<div style="padding: 2rem; color: #ef4444; font-family: monospace;">' +
                    '<h2>❌ Module Loading Error</h2>' +
                    '<p><strong>The following modules or exports are missing:</strong></p>' +
                    '<ul style="text-align: left; max-width: 600px; margin: 1rem auto;">' +
                    validation.errors.map(err => `<li>${err}</li>`).join('') +
                    '</ul>' +
                    '<p style="margin-top: 2rem;">Please refresh the page. If the problem persists, check browser console.</p>' +
                    '<button onclick="location.reload()" style="padding: 0.5rem 1rem; font-size: 1rem; cursor: pointer;">Refresh Page</button>' +
                    '</div>';
                throw new Error('Module validation failed: ' + validation.errors.join(', '));
            }

            if (validation.warnings.length > 0) {
                console.warn('[App] Module validation warnings:', validation.warnings);
            }

            console.log('[App] ✅ All modules validated successfully');

            // ============================================
            // Import from External Modules (VALIDATED)
            // ============================================
            // Utility functions are in DawsOS.Utils namespace
            const {
                formatCurrency,
                formatPercentage,
                formatNumber,
                formatDate,
                formatValue,
                getColorClass,
                LoadingSpinner,
                ErrorMessage,
                EmptyState,
                RetryableError,
                useCachedQuery,
                useCachedMutation
            } = DawsOS.Utils;

            // Panel components are in DawsOS.Panels namespace
            const {
                MetricsGridPanel,
                TablePanel,
                LineChartPanel,
                NewsListPanel,
                PieChartPanel,
                DonutChartPanel,
                ScorecardPanel,
                BarChartPanel,
                ActionCardsPanel,
                CycleCardPanel,
                DualListPanel,
                ReportViewerPanel
            } = DawsOS.Panels;

            // Page components are in DawsOS.Pages namespace
            const {
                LoginPage,
                DashboardPage,
                DashboardPageLegacy,
                HoldingsPage,
                SecurityDetailPage,
                TransactionsPage,
                PerformancePage,
                MacroCyclesPage,
                ScenariosPage,
                RiskPage,
                AttributionPage,
                OptimizerPage,
                RatingsPage,
                AIInsightsPage,
                AIAssistantPage,
                AlertsPage,
                ReportsPage,
                CorporateActionsPage,
                MarketDataPage,
                SettingsPage
            } = DawsOS.Pages;

            // Context system is in DawsOS.Context namespace
            const {
                getCurrentPortfolioId,
                UserContext,
                UserContextProvider,
                useUserContext,
                PortfolioSelector
            } = DawsOS.Context;

            // Pattern system is in DawsOS.PatternSystem namespace
            const {
                getDataByPath,
                PatternRenderer,
                PanelRenderer,
                patternRegistry,
                queryKeys,
                queryHelpers
            } = DawsOS.PatternSystem;

            // ===== UNIFIED PATTERN INTEGRATION SYSTEM =====
            
            
            // ----- OPTIMIZATION LOGIC -----
            
            /**
             * Generate trade proposals based on portfolio optimization
             * @param {object} portfolio - Current portfolio
             * @param {object} targetAllocation - Target allocation
             * @param {object} constraints - Trading constraints
             * @returns {Array} Trade proposals
             */
            const generateTradeProposals = (portfolio, targetAllocation, constraints = {}) => {
                const proposals = [];
                const currentHoldings = portfolio.holdings || [];
                const totalValue = portfolio.value || 0;
                const maxTrades = constraints.maxTrades || 10;
                const minTradeSize = constraints.minTradeSize || 1000;
                const maxPositionSize = constraints.maxPositionSize || 0.15;
                
                // Calculate current allocations
                const currentAllocations = {};
                currentHoldings.forEach(holding => {
                    const allocation = holding.value / totalValue;
                    currentAllocations[holding.symbol] = allocation;
                });
                
                // Identify required trades
                Object.keys(targetAllocation).forEach(symbol => {
                    const current = currentAllocations[symbol] || 0;
                    const target = targetAllocation[symbol];
                    const difference = target - current;
                    const dollarDifference = difference * totalValue;
                    
                    if (Math.abs(dollarDifference) > minTradeSize) {
                        const holding = currentHoldings.find(h => h.symbol === symbol) || {};
                        const price = holding.price || 100;
                        const shares = Math.round(dollarDifference / price);
                        
                        proposals.push({
                            id: proposals.length + 1,
                            action: dollarDifference > 0 ? 'BUY' : 'SELL',
                            symbol,
                            shares: Math.abs(shares),
                            price,
                            value: Math.abs(dollarDifference),
                            currentAllocation: current * 100,
                            targetAllocation: target * 100,
                            impact: (difference * 100).toFixed(2) + '%',
                            reason: generateTradeReason(current, target, symbol),
                            confidence: calculateTradeConfidence(difference, symbol),
                            priority: Math.abs(difference) // Higher difference = higher priority
                        });
                    }
                });
                
                // Sort by priority and limit to maxTrades
                return proposals
                    .sort((a, b) => b.priority - a.priority)
                    .slice(0, maxTrades)
                    .map((trade, index) => ({ ...trade, id: index + 1 }));
            };
            
            /**
             * Helper function to generate trade reason
             */
            const generateTradeReason = (current, target, symbol) => {
                const diff = target - current;
                if (diff > 0.05) return `Increase ${symbol} exposure to target`;
                if (diff < -0.05) return `Reduce ${symbol} concentration`;
                if (diff > 0) return `Rebalance ${symbol} to target weight`;
                return `Trim ${symbol} position`;
            };
            
            /**
             * Helper function to calculate trade confidence
             */
            const calculateTradeConfidence = (difference, symbol) => {
                const baseConfidence = 70;
                const differenceBonus = Math.min(Math.abs(difference) * 100, 20);
                const volatilityPenalty = Math.random() * 10; // Placeholder for actual volatility
                return Math.min(95, Math.max(50, baseConfidence + differenceBonus - volatilityPenalty));
            };
            
            /**
             * Analyze trade impact on portfolio metrics
             * @param {Array} trades - Proposed trades
             * @param {object} portfolio - Current portfolio
             * @param {object} marketData - Market data for calculations
             * @returns {object} Impact analysis results
             */
            const analyzeTradeImpact = (trades, portfolio, marketData = {}) => {
                const currentMetrics = portfolio.metrics || {};
                const currentReturn = currentMetrics.expectedReturn || 8;
                const currentVolatility = currentMetrics.volatility || 15;
                const currentSharpe = currentMetrics.sharpe || 0.85;
                const currentBeta = currentMetrics.beta || 1.0;
                
                // Simulate post-trade metrics
                let portfolioAfterTrades = { ...portfolio };
                let totalBuyValue = 0;
                let totalSellValue = 0;
                
                trades.forEach(trade => {
                    if (trade.action === 'BUY') {
                        totalBuyValue += trade.value || (trade.shares * trade.price);
                    } else {
                        totalSellValue += trade.value || (trade.shares * trade.price);
                    }
                });
                
                // Calculate expected changes (simplified model)
                const netChange = totalBuyValue - totalSellValue;
                const rebalancingEffect = Math.abs(netChange) / portfolio.value;
                
                // Estimate new metrics
                const returnImprovement = rebalancingEffect * 0.15; // 15% improvement per 1% rebalanced
                const volatilityReduction = rebalancingEffect * 0.2; // 20% reduction per 1% rebalanced
                const betaChange = netChange > 0 ? 0.05 : -0.05; // Directional beta change
                
                const optimizedReturn = currentReturn * (1 + returnImprovement);
                const optimizedVolatility = currentVolatility * (1 - volatilityReduction);
                const optimizedSharpe = calculateSharpeRatio(optimizedReturn / 100, 0.02, optimizedVolatility / 100);
                const optimizedBeta = currentBeta + betaChange;
                
                // Calculate improvement metrics
                const metrics = [
                    {
                        metric: 'Expected Return',
                        current: currentReturn,
                        optimized: optimizedReturn,
                        change: ((optimizedReturn - currentReturn) / currentReturn) * 100,
                        improvement: optimizedReturn > currentReturn
                    },
                    {
                        metric: 'Volatility',
                        current: currentVolatility,
                        optimized: optimizedVolatility,
                        change: ((optimizedVolatility - currentVolatility) / currentVolatility) * 100,
                        improvement: optimizedVolatility < currentVolatility
                    },
                    {
                        metric: 'Sharpe Ratio',
                        current: currentSharpe,
                        optimized: optimizedSharpe,
                        change: optimizedSharpe - currentSharpe,
                        improvement: optimizedSharpe > currentSharpe
                    },
                    {
                        metric: 'Beta',
                        current: currentBeta,
                        optimized: optimizedBeta,
                        change: optimizedBeta - currentBeta,
                        improvement: Math.abs(optimizedBeta - 1) < Math.abs(currentBeta - 1)
                    }
                ];
                
                // Calculate overall improvement score
                const improvementScore = metrics.reduce((score, m) => 
                    score + (m.improvement ? 1 : 0), 0) / metrics.length;
                
                return {
                    metrics,
                    totalBuyValue,
                    totalSellValue,
                    netChange,
                    rebalancingPercentage: rebalancingEffect * 100,
                    improvementScore,
                    recommendation: improvementScore > 0.5 ? 'Execute trades' : 'Review trades',
                    estimatedCost: trades.reduce((sum, t) => sum + (t.shares * t.price * 0.001), 0), // 0.1% transaction cost
                    riskReduction: volatilityReduction * 100,
                    returnEnhancement: returnImprovement * 100
                };
            };
            
            /**
             * Calculate efficient frontier points for portfolio optimization
             * @param {Array} assets - Array of assets with returns and risks
             * @param {object} constraints - Optimization constraints
             * @returns {Array} Efficient frontier points
             */
            const calculateEfficientFrontier = (assets, constraints = {}) => {
                const minRisk = constraints.minRisk || 5;
                const maxRisk = constraints.maxRisk || 25;
                const riskStep = constraints.riskStep || 1;
                const riskFreeRate = constraints.riskFreeRate || 0.02;
                
                const frontierPoints = [];
                
                for (let risk = minRisk; risk <= maxRisk; risk += riskStep) {
                    // Simplified efficient frontier calculation
                    // In reality, this would use mean-variance optimization
                    const baseReturn = 4;
                    const riskPremium = 0.4;
                    const diminishingFactor = Math.log10(risk / 5);
                    
                    // Calculate return for this risk level
                    const expectedReturn = baseReturn + (risk * riskPremium * diminishingFactor);
                    
                    // Add some randomness to simulate real portfolio variations
                    const variation = (Math.random() - 0.5) * 2;
                    const adjustedReturn = expectedReturn + variation;
                    
                    // Calculate Sharpe ratio for this point
                    const sharpe = (adjustedReturn - riskFreeRate * 100) / risk;
                    
                    frontierPoints.push({
                        risk,
                        return: adjustedReturn,
                        sharpe,
                        isEfficient: sharpe > 0.3,
                        allocation: generateOptimalAllocation(risk)
                    });
                }
                
                return frontierPoints;
            };
            
            /**
             * Helper to generate optimal allocation for a given risk level
             */
            const generateOptimalAllocation = (riskLevel) => {
                const conservativeRatio = Math.max(0, (25 - riskLevel) / 20);
                const aggressiveRatio = Math.min(1, riskLevel / 25);
                
                return {
                    stocks: aggressiveRatio * 70,
                    bonds: conservativeRatio * 40,
                    alternatives: 10 + (riskLevel / 25) * 10,
                    cash: Math.max(5, 20 - riskLevel)
                };
            };
            
            /**
             * Optimize portfolio for risk/return characteristics
             * @param {object} portfolio - Current portfolio
             * @param {object} objectives - Optimization objectives
             * @param {object} constraints - Optimization constraints
             * @returns {object} Optimization results
             */
            const optimizeRiskReturn = (portfolio, objectives = {}, constraints = {}) => {
                const targetReturn = objectives.targetReturn || 10;
                const maxRisk = objectives.maxRisk || 20;
                const riskTolerance = objectives.riskTolerance || 'moderate';
                
                // Current portfolio metrics
                const currentMetrics = {
                    return: portfolio.metrics?.expectedReturn || 8,
                    risk: portfolio.metrics?.volatility || 15,
                    sharpe: portfolio.metrics?.sharpe || 0.85,
                    diversification: portfolio.metrics?.diversification || 0.7
                };
                
                // Define optimal targets based on risk tolerance
                let optimalTargets = {};
                switch (riskTolerance) {
                    case 'conservative':
                        optimalTargets = {
                            return: 6,
                            risk: 10,
                            stockAllocation: 40,
                            bondAllocation: 50,
                            alternativeAllocation: 10
                        };
                        break;
                    case 'aggressive':
                        optimalTargets = {
                            return: 12,
                            risk: 20,
                            stockAllocation: 80,
                            bondAllocation: 10,
                            alternativeAllocation: 10
                        };
                        break;
                    default: // moderate
                        optimalTargets = {
                            return: 9,
                            risk: 15,
                            stockAllocation: 60,
                            bondAllocation: 30,
                            alternativeAllocation: 10
                        };
                }
                
                // Calculate optimization actions needed
                const actions = [];
                
                if (currentMetrics.risk > optimalTargets.risk) {
                    actions.push({
                        type: 'REDUCE_RISK',
                        description: 'Reduce portfolio volatility',
                        target: optimalTargets.risk,
                        current: currentMetrics.risk,
                        priority: 'HIGH'
                    });
                }
                
                if (currentMetrics.return < optimalTargets.return * 0.9) {
                    actions.push({
                        type: 'INCREASE_RETURN',
                        description: 'Enhance expected returns',
                        target: optimalTargets.return,
                        current: currentMetrics.return,
                        priority: 'MEDIUM'
                    });
                }
                
                if (currentMetrics.sharpe < 1.0) {
                    actions.push({
                        type: 'IMPROVE_EFFICIENCY',
                        description: 'Improve risk-adjusted returns',
                        target: 1.0,
                        current: currentMetrics.sharpe,
                        priority: 'HIGH'
                    });
                }
                
                // Generate rebalancing recommendations
                const rebalancingNeeded = Math.abs(currentMetrics.return - optimalTargets.return) > 1 ||
                                         Math.abs(currentMetrics.risk - optimalTargets.risk) > 2;
                
                return {
                    currentMetrics,
                    optimalTargets,
                    actions,
                    rebalancingNeeded,
                    optimizationScore: calculateOptimizationScore(currentMetrics, optimalTargets),
                    recommendations: generateOptimizationRecommendations(actions),
                    estimatedImprovement: {
                        return: optimalTargets.return - currentMetrics.return,
                        risk: currentMetrics.risk - optimalTargets.risk,
                        sharpe: (optimalTargets.return - 2) / optimalTargets.risk - currentMetrics.sharpe
                    }
                };
            };
            
            /**
             * Helper to calculate optimization score
             */
            const calculateOptimizationScore = (current, target) => {
                const returnScore = Math.min(current.return / target.return, 1);
                const riskScore = Math.min(target.risk / current.risk, 1);
                const sharpeScore = Math.min(current.sharpe / 1.0, 1);
                return (returnScore + riskScore + sharpeScore) / 3 * 10;
            };
            
            /**
             * Helper to generate optimization recommendations
             */
            const generateOptimizationRecommendations = (actions) => {
                const recommendations = [];
                actions.forEach(action => {
                    switch (action.type) {
                        case 'REDUCE_RISK':
                            recommendations.push('Increase allocation to bonds and defensive assets');
                            recommendations.push('Consider adding low-correlation alternatives');
                            break;
                        case 'INCREASE_RETURN':
                            recommendations.push('Increase exposure to growth assets');
                            recommendations.push('Consider sector rotation to high-momentum areas');
                            break;
                        case 'IMPROVE_EFFICIENCY':
                            recommendations.push('Rebalance to optimal asset allocation');
                            recommendations.push('Reduce concentration in underperforming positions');
                            break;
                    }
                });
                return recommendations;
            };
            
            // ----- ATTRIBUTION ANALYSIS LOGIC -----
            
            /**
             * Calculate currency attribution for multi-currency portfolios
             * @param {Array} positions - Portfolio positions with currency exposure
             * @param {object} fxRates - Foreign exchange rates
             * @param {string} baseCurrency - Base currency for reporting
             * @returns {object} Currency attribution analysis
             */
            const calculateCurrencyAttribution = (positions, fxRates, baseCurrency = 'USD') => {
                const attribution = {
                    localReturns: {},
                    fxImpact: {},
                    crossEffects: {},
                    totalAttribution: 0
                };
                
                positions.forEach(position => {
                    const currency = position.currency || baseCurrency;
                    const localReturn = position.localReturn || 0;
                    const fxReturn = fxRates[currency]?.change || 0;
                    
                    // Local return contribution
                    const localContribution = position.weight * localReturn;
                    
                    // FX impact contribution
                    const fxContribution = position.weight * fxReturn;
                    
                    // Cross effect (interaction between local and FX)
                    const crossEffect = position.weight * localReturn * fxReturn;
                    
                    // Aggregate by currency
                    if (!attribution.localReturns[currency]) {
                        attribution.localReturns[currency] = 0;
                        attribution.fxImpact[currency] = 0;
                        attribution.crossEffects[currency] = 0;
                    }
                    
                    attribution.localReturns[currency] += localContribution;
                    attribution.fxImpact[currency] += fxContribution;
                    attribution.crossEffects[currency] += crossEffect;
                });
                
                // Calculate totals
                const totalLocal = Object.values(attribution.localReturns).reduce((sum, val) => sum + val, 0);
                const totalFx = Object.values(attribution.fxImpact).reduce((sum, val) => sum + val, 0);
                const totalCross = Object.values(attribution.crossEffects).reduce((sum, val) => sum + val, 0);
                
                attribution.totalAttribution = totalLocal + totalFx + totalCross;
                
                // Add summary statistics
                attribution.summary = {
                    localReturnContribution: totalLocal,
                    fxContribution: totalFx,
                    interactionEffect: totalCross,
                    totalReturn: attribution.totalAttribution,
                    fxImpactPercentage: totalFx / Math.abs(attribution.totalAttribution) * 100
                };
                
                // Identify major currency impacts
                attribution.majorImpacts = Object.keys(attribution.fxImpact)
                    .map(currency => ({
                        currency,
                        impact: attribution.fxImpact[currency],
                        percentage: attribution.fxImpact[currency] / totalFx * 100
                    }))
                    .sort((a, b) => Math.abs(b.impact) - Math.abs(a.impact))
                    .slice(0, 5);
                
                return attribution;
            };
            
            /**
             * Calculate factor attribution (selection, allocation, interaction)
             * @param {object} portfolio - Portfolio with holdings and returns
             * @param {object} benchmark - Benchmark for comparison
             * @param {Array} factors - Factors to analyze
             * @returns {object} Factor attribution results
             */
            const calculateFactorAttribution = (portfolio, benchmark, factors = []) => {
                const defaultFactors = ['selection', 'allocation', 'interaction'];
                const analysisFactors = factors.length > 0 ? factors : defaultFactors;
                
                const attribution = {
                    factors: {},
                    totalActive: 0,
                    contributions: []
                };
                
                // Calculate portfolio and benchmark returns
                const portfolioReturn = portfolio.return || 0;
                const benchmarkReturn = benchmark.return || 0;
                const activeReturn = portfolioReturn - benchmarkReturn;
                
                // Selection effect (stock picking within sectors)
                const selectionEffect = portfolio.sectors?.reduce((total, sector) => {
                    const sectorReturn = sector.return || 0;
                    const benchmarkSectorReturn = benchmark.sectors?.find(s => s.name === sector.name)?.return || 0;
                    const benchmarkWeight = benchmark.sectors?.find(s => s.name === sector.name)?.weight || 0;
                    return total + benchmarkWeight * (sectorReturn - benchmarkSectorReturn);
                }, 0) || 0;
                
                // Allocation effect (sector weighting decisions)
                const allocationEffect = portfolio.sectors?.reduce((total, sector) => {
                    const portfolioWeight = sector.weight || 0;
                    const benchmarkWeight = benchmark.sectors?.find(s => s.name === sector.name)?.weight || 0;
                    const benchmarkSectorReturn = benchmark.sectors?.find(s => s.name === sector.name)?.return || 0;
                    return total + (portfolioWeight - benchmarkWeight) * (benchmarkSectorReturn - benchmarkReturn);
                }, 0) || 0;
                
                // Interaction effect (combined selection and allocation)
                const interactionEffect = portfolio.sectors?.reduce((total, sector) => {
                    const portfolioWeight = sector.weight || 0;
                    const benchmarkWeight = benchmark.sectors?.find(s => s.name === sector.name)?.weight || 0;
                    const sectorReturn = sector.return || 0;
                    const benchmarkSectorReturn = benchmark.sectors?.find(s => s.name === sector.name)?.return || 0;
                    return total + (portfolioWeight - benchmarkWeight) * (sectorReturn - benchmarkSectorReturn);
                }, 0) || 0;
                
                // Other factors (trading costs, currency, etc.)
                const tradingEffect = portfolio.tradingCosts || 0;
                const currencyEffect = portfolio.currencyImpact || 0;
                const residual = activeReturn - (selectionEffect + allocationEffect + interactionEffect + tradingEffect + currencyEffect);
                
                // Populate attribution object
                attribution.factors = {
                    selection: selectionEffect,
                    allocation: allocationEffect,
                    interaction: interactionEffect,
                    trading: tradingEffect,
                    currency: currencyEffect,
                    residual: residual
                };
                
                attribution.totalActive = activeReturn;
                
                // Calculate contribution percentages
                Object.keys(attribution.factors).forEach(factor => {
                    const contribution = attribution.factors[factor];
                    attribution.contributions.push({
                        factor: factor.charAt(0).toUpperCase() + factor.slice(1),
                        contribution: contribution * 100,
                        percentage: activeReturn !== 0 ? (contribution / activeReturn) * 100 : 0
                    });
                });
                
                return attribution;
            };
            
            /**
             * Calculate sector performance attribution
             * @param {Array} sectors - Portfolio sectors with weights and returns
             * @param {Array} benchmarkSectors - Benchmark sectors
             * @returns {object} Sector attribution analysis
             */
            const calculateSectorAttribution = (sectors, benchmarkSectors) => {
                const attribution = [];
                const totalPortfolioReturn = sectors.reduce((sum, s) => sum + s.weight * s.return, 0);
                const totalBenchmarkReturn = benchmarkSectors.reduce((sum, s) => sum + s.weight * s.return, 0);
                
                sectors.forEach(sector => {
                    const benchmarkSector = benchmarkSectors.find(s => s.name === sector.name) || {
                        weight: 0,
                        return: totalBenchmarkReturn
                    };
                    
                    // Calculate attribution components
                    const allocationEffect = (sector.weight - benchmarkSector.weight) * 
                                            (benchmarkSector.return - totalBenchmarkReturn);
                    const selectionEffect = benchmarkSector.weight * 
                                          (sector.return - benchmarkSector.return);
                    const interactionEffect = (sector.weight - benchmarkSector.weight) * 
                                             (sector.return - benchmarkSector.return);
                    
                    const totalContribution = allocationEffect + selectionEffect + interactionEffect;
                    
                    attribution.push({
                        sector: sector.name,
                        weight: sector.weight,
                        return: sector.return,
                        benchmarkWeight: benchmarkSector.weight,
                        benchmarkReturn: benchmarkSector.return,
                        activeWeight: sector.weight - benchmarkSector.weight,
                        activeReturn: sector.return - benchmarkSector.return,
                        allocation: allocationEffect * 100,
                        selection: selectionEffect * 100,
                        interaction: interactionEffect * 100,
                        contribution: totalContribution * 100
                    });
                });
                
                // Sort by total contribution
                attribution.sort((a, b) => Math.abs(b.contribution) - Math.abs(a.contribution));
                
                return {
                    sectorDetails: attribution,
                    totalActive: (totalPortfolioReturn - totalBenchmarkReturn) * 100,
                    topContributors: attribution.slice(0, 3),
                    bottomContributors: attribution.slice(-3),
                    summary: {
                        allocationTotal: attribution.reduce((sum, s) => sum + s.allocation, 0),
                        selectionTotal: attribution.reduce((sum, s) => sum + s.selection, 0),
                        interactionTotal: attribution.reduce((sum, s) => sum + s.interaction, 0)
                    }
                };
            };
            
            /**
             * Calculate multi-period attribution (linking returns over time)
             * @param {Array} periods - Array of period data with returns
             * @param {string} method - Attribution method ('arithmetic' or 'geometric')
             * @returns {object} Multi-period attribution results
             */
            const calculateMultiPeriodAttribution = (periods, method = 'geometric') => {
                if (!periods || periods.length === 0) {
                    return {
                        totalReturn: 0,
                        annualizedReturn: 0,
                        periods: []
                    };
                }
                
                let cumulativeReturn = 1;
                const periodResults = [];
                
                periods.forEach((period, index) => {
                    const periodReturn = period.return || 0;
                    const localReturn = period.localReturn || periodReturn;
                    const currencyReturn = period.currencyReturn || 0;
                    
                    let contribution;
                    if (method === 'geometric') {
                        // Geometric linking
                        contribution = cumulativeReturn * periodReturn;
                        cumulativeReturn *= (1 + periodReturn);
                    } else {
                        // Arithmetic linking
                        contribution = periodReturn;
                        cumulativeReturn += periodReturn;
                    }
                    
                    periodResults.push({
                        period: period.name || `Period ${index + 1}`,
                        return: periodReturn * 100,
                        localReturn: localReturn * 100,
                        currencyReturn: currencyReturn * 100,
                        contribution: contribution * 100,
                        cumulativeReturn: method === 'geometric' ? 
                            (cumulativeReturn - 1) * 100 : 
                            cumulativeReturn * 100
                    });
                });
                
                // Calculate annualized return
                const totalReturn = method === 'geometric' ? 
                    cumulativeReturn - 1 : 
                    cumulativeReturn;
                const years = periods.length / 12; // Assuming monthly periods
                const annualizedReturn = method === 'geometric' ?
                    Math.pow(cumulativeReturn, 1 / years) - 1 :
                    totalReturn / years;
                
                return {
                    totalReturn: totalReturn * 100,
                    annualizedReturn: annualizedReturn * 100,
                    periods: periodResults,
                    method,
                    volatility: calculatePeriodVolatility(periods),
                    bestPeriod: periodResults.reduce((best, p) => 
                        p.return > best.return ? p : best),
                    worstPeriod: periodResults.reduce((worst, p) => 
                        p.return < worst.return ? p : worst)
                };
            };
            
            /**
             * Helper to calculate period volatility
             */
            const calculatePeriodVolatility = (periods) => {
                if (periods.length < 2) return 0;
                
                const returns = periods.map(p => p.return || 0);
                const mean = returns.reduce((sum, r) => sum + r, 0) / returns.length;
                const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
                return Math.sqrt(variance) * Math.sqrt(12) * 100; // Annualized
            };
            
            // ----- RATINGS ANALYSIS LOGIC -----
            
            /**
             * Calculate Buffett Checklist score for a company
             * @param {object} company - Company data with financials
             * @param {object} weights - Criteria weights
             * @returns {object} Buffett checklist analysis
             */
            const calculateBuffettChecklistScore = (company, weights = {}) => {
                const defaultWeights = {
                    simpleBusiness: 0.10,
                    consistentHistory: 0.10,
                    favorableProspects: 0.10,
                    rationalManagement: 0.08,
                    attractivePrice: 0.12,
                    highROE: 0.12,
                    lowDebt: 0.08,
                    highMargins: 0.10,
                    moat: 0.15,
                    ownerEarnings: 0.05
                };
                
                const criteriaWeights = { ...defaultWeights, ...weights };
                const scores = {};
                let totalScore = 0;
                
                // Simple Business (based on business complexity metrics)
                scores.simpleBusiness = company.businessSegments <= 3 ? 90 : 
                                        company.businessSegments <= 5 ? 70 : 50;
                
                // Consistent Operating History
                const consistencyYears = company.profitableYears || 0;
                scores.consistentHistory = Math.min(100, consistencyYears * 10);
                
                // Favorable Long-term Prospects
                const growthRate = company.expectedGrowth || 0;
                scores.favorableProspects = Math.min(100, 50 + growthRate * 2);
                
                // Rational Management
                scores.rationalManagement = company.managementScore || 75;
                
                // Attractive Price
                const peRatio = company.peRatio || 20;
                scores.attractivePrice = peRatio < 15 ? 90 :
                                         peRatio < 20 ? 70 :
                                         peRatio < 25 ? 50 : 30;
                
                // High ROE
                const roe = company.roe || 15;
                scores.highROE = Math.min(100, roe * 4);
                
                // Low Debt
                const debtToEquity = company.debtToEquity || 0.5;
                scores.lowDebt = debtToEquity < 0.3 ? 95 :
                                debtToEquity < 0.5 ? 80 :
                                debtToEquity < 1.0 ? 60 : 30;
                
                // High Profit Margins
                const profitMargin = company.profitMargin || 10;
                scores.highMargins = Math.min(100, profitMargin * 5);
                
                // Moat/Competitive Advantage
                scores.moat = company.moatScore || 70;
                
                // Owner Earnings Growth
                const earningsGrowth = company.earningsGrowth || 5;
                scores.ownerEarnings = Math.min(100, 50 + earningsGrowth * 3);
                
                // Calculate weighted total score
                Object.keys(scores).forEach(criteria => {
                    totalScore += scores[criteria] * criteriaWeights[criteria];
                });
                
                // Determine recommendation
                let recommendation = 'Hold';
                if (totalScore >= 85) recommendation = 'Strong Buy';
                else if (totalScore >= 75) recommendation = 'Buy';
                else if (totalScore >= 60) recommendation = 'Hold';
                else if (totalScore >= 45) recommendation = 'Sell';
                else recommendation = 'Strong Sell';
                
                return {
                    scores,
                    totalScore: Math.round(totalScore),
                    recommendation,
                    strengths: Object.keys(scores).filter(k => scores[k] >= 80),
                    weaknesses: Object.keys(scores).filter(k => scores[k] < 60),
                    details: Object.keys(scores).map(criteria => ({
                        criteria: criteria.replace(/([A-Z])/g, ' $1').trim(),
                        score: scores[criteria],
                        weight: criteriaWeights[criteria] * 100,
                        contribution: scores[criteria] * criteriaWeights[criteria]
                    }))
                };
            };
            
            /**
             * Calculate Dividend Safety Score
             * @param {object} dividendData - Company dividend metrics
             * @returns {object} Dividend safety analysis
             */
            const calculateDividendSafetyScore = (dividendData) => {
                const factors = {};
                let totalScore = 0;
                
                // Payout Ratio (lower is safer)
                const payoutRatio = dividendData.payoutRatio || 50;
                factors.payoutRatio = payoutRatio < 40 ? 95 :
                                      payoutRatio < 60 ? 85 :
                                      payoutRatio < 80 ? 65 : 30;
                
                // Free Cash Flow Coverage
                const fcfCoverage = dividendData.fcfCoverage || 1.5;
                factors.freeCashFlow = fcfCoverage > 2 ? 95 :
                                      fcfCoverage > 1.5 ? 85 :
                                      fcfCoverage > 1 ? 70 : 40;
                
                // Debt/Equity Ratio
                const debtEquity = dividendData.debtToEquity || 0.5;
                factors.debtEquity = debtEquity < 0.3 ? 90 :
                                    debtEquity < 0.6 ? 75 :
                                    debtEquity < 1 ? 60 : 30;
                
                // Earnings Stability
                const earningsVolatility = dividendData.earningsVolatility || 10;
                factors.earningsStability = earningsVolatility < 5 ? 95 :
                                           earningsVolatility < 10 ? 85 :
                                           earningsVolatility < 20 ? 70 : 50;
                
                // Revenue Growth
                const revenueGrowth = dividendData.revenueGrowth || 5;
                factors.revenueGrowth = revenueGrowth > 10 ? 90 :
                                       revenueGrowth > 5 ? 80 :
                                       revenueGrowth > 0 ? 70 : 50;
                
                // Dividend History (years of consistent payments)
                const dividendYears = dividendData.consecutiveDividendYears || 10;
                factors.dividendHistory = Math.min(100, dividendYears * 3);
                
                // Calculate weighted score
                const weights = {
                    payoutRatio: 0.20,
                    freeCashFlow: 0.20,
                    debtEquity: 0.15,
                    earningsStability: 0.20,
                    revenueGrowth: 0.10,
                    dividendHistory: 0.15
                };
                
                Object.keys(factors).forEach(factor => {
                    totalScore += factors[factor] * weights[factor];
                });
                
                // Determine safety rating
                let safetyRating = 'Safe';
                if (totalScore >= 85) safetyRating = 'Very Safe';
                else if (totalScore >= 70) safetyRating = 'Safe';
                else if (totalScore >= 55) safetyRating = 'Moderate';
                else if (totalScore >= 40) safetyRating = 'At Risk';
                else safetyRating = 'High Risk';
                
                return {
                    overallScore: Math.round(totalScore),
                    factors,
                    safetyRating,
                    sustainabilityYears: estimateDividendSustainability(dividendData),
                    cutProbability: 100 - totalScore,
                    keyRisks: identifyDividendRisks(factors)
                };
            };
            
            /**
             * Helper to estimate dividend sustainability
             */
            const estimateDividendSustainability = (data) => {
                const payoutRatio = data.payoutRatio || 50;
                const earningsGrowth = data.earningsGrowth || 5;
                
                if (payoutRatio >= 100) return 0;
                if (payoutRatio >= 90) return 1;
                if (earningsGrowth > 10 && payoutRatio < 60) return 10;
                if (earningsGrowth > 5 && payoutRatio < 70) return 5;
                return 3;
            };
            
            /**
             * Helper to identify dividend risks
             */
            const identifyDividendRisks = (factors) => {
                const risks = [];
                if (factors.payoutRatio < 70) risks.push('High payout ratio');
                if (factors.freeCashFlow < 70) risks.push('Weak cash flow coverage');
                if (factors.debtEquity < 60) risks.push('High debt levels');
                if (factors.earningsStability < 70) risks.push('Volatile earnings');
                return risks;
            };
            
            /**
             * Calculate Moat Strength
             * @param {object} companyData - Company competitive advantage data
             * @returns {object} Moat strength analysis
             */
            const calculateMoatStrength = (companyData) => {
                const moatFactors = {};
                
                // Brand Value
                const brandValue = companyData.brandValue || 50;
                moatFactors.brandValue = Math.min(100, brandValue * 1.5);
                
                // Switching Costs
                const switchingCosts = companyData.switchingCosts || 'medium';
                moatFactors.switchingCosts = switchingCosts === 'high' ? 90 :
                                             switchingCosts === 'medium' ? 60 : 30;
                
                // Network Effects
                const networkEffects = companyData.networkEffects || false;
                moatFactors.networkEffects = networkEffects ? 85 : 40;
                
                // Cost Advantages
                const costAdvantage = companyData.costAdvantage || 0;
                moatFactors.costAdvantage = Math.min(100, 50 + costAdvantage * 2);
                
                // Intangible Assets (patents, licenses, etc.)
                const intangibles = companyData.intangibleAssets || 50;
                moatFactors.intangibleAssets = intangibles;
                
                // Efficient Scale
                const marketShare = companyData.marketShare || 20;
                moatFactors.efficientScale = Math.min(100, marketShare * 2.5);
                
                // Calculate overall moat strength
                const moatScore = Object.values(moatFactors).reduce((sum, score) => 
                    sum + score, 0) / Object.keys(moatFactors).length;
                
                // Determine moat rating
                let moatRating = 'No Moat';
                if (moatScore >= 80) moatRating = 'Wide Moat';
                else if (moatScore >= 60) moatRating = 'Narrow Moat';
                else if (moatScore >= 40) moatRating = 'Emerging Moat';
                
                // Compare to industry average
                const industryAverage = companyData.industryAverageMoat || 50;
                const relativeStrength = moatScore - industryAverage;
                
                return {
                    moatScore: Math.round(moatScore),
                    moatRating,
                    factors: moatFactors,
                    relativeToIndustry: relativeStrength > 0 ? 'Above Average' : 'Below Average',
                    competitiveAdvantages: Object.keys(moatFactors)
                        .filter(k => moatFactors[k] >= 70)
                        .map(k => k.replace(/([A-Z])/g, ' $1').trim()),
                    vulnerabilities: Object.keys(moatFactors)
                        .filter(k => moatFactors[k] < 50)
                        .map(k => k.replace(/([A-Z])/g, ' $1').trim()),
                    sustainabilityYears: estimateMoatDurability(moatScore, companyData)
                };
            };
            
            /**
             * Helper to estimate moat durability
             */
            const estimateMoatDurability = (moatScore, data) => {
                if (moatScore >= 80 && data.innovationRate > 5) return 20;
                if (moatScore >= 70) return 15;
                if (moatScore >= 60) return 10;
                if (moatScore >= 50) return 7;
                return 5;
            };
            
            /**
             * Calculate Resilience Rating
             * @param {object} resilienceData - Company resilience metrics
             * @returns {object} Resilience analysis
             */
            const calculateResilienceRating = (resilienceData) => {
                const factors = {};
                
                // Financial Strength
                const cashRatio = resilienceData.cashRatio || 0.5;
                const debtCoverage = resilienceData.debtCoverage || 2;
                factors.financialStrength = (Math.min(100, cashRatio * 100) + 
                                            Math.min(100, debtCoverage * 25)) / 2;
                
                // Market Position
                const marketShare = resilienceData.marketShare || 15;
                const competitivePosition = resilienceData.competitiveRank || 5;
                factors.marketPosition = Math.min(100, marketShare * 3 + (10 - competitivePosition) * 5);
                
                // Adaptability
                const innovationScore = resilienceData.innovationScore || 50;
                const pivotHistory = resilienceData.successfulPivots || 0;
                factors.adaptability = Math.min(100, innovationScore + pivotHistory * 10);
                
                // Management Quality
                const managementTenure = resilienceData.avgManagementTenure || 5;
                const executionScore = resilienceData.executionScore || 70;
                factors.managementQuality = (Math.min(100, managementTenure * 10) + executionScore) / 2;
                
                // Diversification
                const revenueSources = resilienceData.revenueSources || 3;
                const geographicDiversity = resilienceData.geographicMarkets || 5;
                factors.diversification = Math.min(100, (revenueSources * 10 + geographicDiversity * 5));
                
                // Innovation Capability
                const rdSpending = resilienceData.rdAsPercentOfRevenue || 5;
                const patentCount = resilienceData.patents || 10;
                factors.innovation = Math.min(100, rdSpending * 5 + Math.log10(patentCount + 1) * 20);
                
                // Calculate overall resilience
                const resilienceScore = Object.values(factors).reduce((sum, score) => 
                    sum + score, 0) / Object.keys(factors).length;
                
                // Determine resilience rating
                let rating = 'Moderate';
                let status = 'Stable';
                
                if (resilienceScore >= 85) {
                    rating = 'Exceptional';
                    status = 'Antifragile';
                } else if (resilienceScore >= 75) {
                    rating = 'Strong';
                    status = 'Robust';
                } else if (resilienceScore >= 60) {
                    rating = 'Good';
                    status = 'Resilient';
                } else if (resilienceScore >= 45) {
                    rating = 'Moderate';
                    status = 'Stable';
                } else {
                    rating = 'Weak';
                    status = 'Vulnerable';
                }
                
                return {
                    resilienceScore: Math.round(resilienceScore),
                    rating,
                    status,
                    factors,
                    crisisReadiness: resilienceScore > 70,
                    recoveryTime: estimateRecoveryTime(resilienceScore),
                    keyStrengths: Object.keys(factors)
                        .filter(k => factors[k] >= 75)
                        .map(k => k.replace(/([A-Z])/g, ' $1').trim()),
                    improvements: Object.keys(factors)
                        .filter(k => factors[k] < 60)
                        .map(k => k.replace(/([A-Z])/g, ' $1').trim())
                };
            };
            
            /**
             * Helper to estimate recovery time from crisis
             */
            const estimateRecoveryTime = (resilienceScore) => {
                if (resilienceScore >= 80) return '3-6 months';
                if (resilienceScore >= 70) return '6-12 months';
                if (resilienceScore >= 60) return '12-18 months';
                if (resilienceScore >= 50) return '18-24 months';
                return '24+ months';
            };
            
            
            // ============================================
            // Caching Layer (React Query-Inspired)
            // ============================================
            
            /**
             * CacheManager - React Query-inspired caching system
             * 
             * Features:
             * - Query key-based caching
             * - Stale-while-revalidate pattern
             * - Automatic garbage collection
             * - Request deduplication
             * - Cache invalidation on mutations
             * - Background refetching
             * 
             * Inspired by React Query patterns from the TypeScript implementation
             */
            // CacheManager, ErrorHandler, and FormValidator are now loaded from external modules
            // (frontend/cache-manager.js, frontend/error-handler.js, frontend/form-validator.js)
            // Imported above and available as const CacheManager, ErrorHandler, FormValidator
            
            // ============================================
            // ERROR BOUNDARY COMPONENT
            // ============================================
            
            /**
             * ErrorBoundary - Catches JavaScript errors in component tree
             * Provides fallback UI and recovery options
             */
            class ErrorBoundary extends React.Component {
                constructor(props) {
                    super(props);
                    this.state = {
                        hasError: false,
                        error: null,
                        errorInfo: null,
                        errorCount: 0,
                        isAutoRecovering: false,
                        autoRecoveryMessage: null
                    };
                    this.autoRecoveryTimer = null;
                }
                
                static getDerivedStateFromError(error) {
                    // Update state to render error UI
                    return { hasError: true };
                }
                
                componentDidCatch(error, errorInfo) {
                    // Log error details for debugging
                    ErrorHandler.logError(error, { 
                        componentStack: errorInfo.componentStack,
                        props: this.props 
                    });
                    
                    // Check for portfolio_id error and auto-recover
                    const errorMessage = error?.toString() || '';
                    const errorStack = error?.stack || '';
                    const componentStack = errorInfo?.componentStack || '';
                    
                    if (errorMessage.includes('portfolio_id') || 
                        errorStack.includes('portfolio_id') ||
                        componentStack.includes('portfolio_id')) {
                        
                        console.log('[ErrorBoundary] Detected portfolio_id error - initiating auto-recovery');
                        console.log('[ErrorBoundary] Error details:', {
                            message: errorMessage,
                            stack: errorStack.slice(0, 500),
                            component: componentStack.slice(0, 500)
                        });
                        
                        // Set auto-recovery state
                        this.setState({
                            error,
                            errorInfo,
                            isAutoRecovering: true,
                            autoRecoveryMessage: 'Refreshing portfolio data...',
                            errorCount: this.state.errorCount + 1
                        });
                        
                        // Clear any existing timer
                        if (this.autoRecoveryTimer) {
                            clearTimeout(this.autoRecoveryTimer);
                        }
                        
                        // Auto-reload after 2 seconds
                        this.autoRecoveryTimer = setTimeout(() => {
                            console.log('[ErrorBoundary] Auto-recovery: Reloading page');
                            window.location.reload();
                        }, 2000);
                        
                    } else {
                        // Regular error handling for non-portfolio_id errors
                        console.log('[ErrorBoundary] Regular error caught:', errorMessage);
                        
                        // Update state with error details
                        this.setState(prevState => ({
                            error,
                            errorInfo,
                            errorCount: prevState.errorCount + 1,
                            isAutoRecovering: false,
                            autoRecoveryMessage: null
                        }));
                    }
                    
                    // Report to error tracking service (if configured)
                    if (window.errorReporter) {
                        window.errorReporter.report(error, errorInfo);
                    }
                }
                
                componentWillUnmount() {
                    // Clean up timer on unmount
                    if (this.autoRecoveryTimer) {
                        clearTimeout(this.autoRecoveryTimer);
                    }
                }
                
                handleReset = () => {
                    // Clear any auto-recovery timer
                    if (this.autoRecoveryTimer) {
                        clearTimeout(this.autoRecoveryTimer);
                        this.autoRecoveryTimer = null;
                    }
                    
                    // Reset error boundary state
                    this.setState({
                        hasError: false,
                        error: null,
                        errorInfo: null,
                        isAutoRecovering: false,
                        autoRecoveryMessage: null
                    });
                    
                    // Optionally reload the page if errors persist
                    if (this.state.errorCount > 3) {
                        window.location.reload();
                    }
                };
                
                render() {
                    if (this.state.hasError) {
                        // Check if auto-recovering
                        if (this.state.isAutoRecovering) {
                            console.log('[ErrorBoundary] Rendering auto-recovery UI');
                            return e('div', { className: 'error-boundary-fallback' },
                                e('div', { className: 'error-container' },
                                    e('div', { className: 'error-icon' }, '🔄'),
                                    e('h2', { className: 'error-title' }, 'Auto-Recovery in Progress'),
                                    e('p', { className: 'error-description' }, 
                                        this.state.autoRecoveryMessage || 'Refreshing portfolio data...'
                                    ),
                                    e('div', { className: 'loading' },
                                        e('div', { className: 'spinner' })
                                    ),
                                    e('p', { 
                                        style: { 
                                            marginTop: '1rem', 
                                            fontSize: '0.875rem', 
                                            color: 'var(--text-secondary)' 
                                        } 
                                    }, 'Page will reload automatically in a moment...')
                                )
                            );
                        }
                        
                        // Render regular error fallback UI
                        return e('div', { className: 'error-boundary-fallback' },
                            e('div', { className: 'error-container' },
                                e('div', { className: 'error-icon' }, '⚠️'),
                                e('h2', { className: 'error-title' }, 'Something went wrong'),
                                e('p', { className: 'error-description' }, 
                                    'An unexpected error occurred. The application has logged this error and it will be reviewed.'
                                ),
                                
                                // Show error details in development
                                (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') && 
                                this.state.error && e('details', { className: 'error-details' },
                                    e('summary', null, 'Error Details (Development Only)'),
                                    e('pre', { className: 'error-stack' }, 
                                        this.state.error.toString(),
                                        '\n\n',
                                        this.state.errorInfo?.componentStack
                                    )
                                ),
                                
                                e('div', { className: 'error-actions' },
                                    e('button', { 
                                        className: 'btn btn-primary',
                                        onClick: this.handleReset
                                    }, 'Try Again'),
                                    e('button', { 
                                        className: 'btn',
                                        onClick: () => window.location.reload()
                                    }, 'Reload Page')
                                )
                            )
                        );
                    }
                    
                    return this.props.children;
                }
            }
            
            // ============================================
            // DATA PROVENANCE COMPONENTS
            // ============================================
            // Navigation Structure with All 52 Capabilities
            // ============================================
            
            const navigationStructure = [
                {
                    section: 'Portfolio',
                    items: [
                        { id: 'dashboard', label: 'Dashboard', path: '/dashboard' },
                        { id: 'holdings', label: 'Holdings', path: '/holdings' },
                        { id: 'transactions', label: 'Transactions', path: '/transactions' },
                        { id: 'performance', label: 'Performance', path: '/performance' },
                        { id: 'corporate-actions', label: 'Corporate Actions', path: '/corporate-actions' }
                    ]
                },
                {
                    section: 'Analysis',
                    items: [
                        { id: 'macro-cycles', label: 'Macro Cycles', path: '/macro-cycles' },
                        { id: 'scenarios', label: 'Scenarios', path: '/scenarios' },
                        { id: 'risk', label: 'Risk Analytics', path: '/risk' },
                        { id: 'attribution', label: 'Attribution', path: '/attribution' }
                    ]
                },
                {
                    section: 'Intelligence',
                    items: [
                        { id: 'optimizer', label: 'Optimizer', path: '/optimizer' },
                        { id: 'ratings', label: 'Ratings', path: '/ratings' },
                        { id: 'ai-insights', label: 'AI Insights', path: '/ai-insights' },
                        { id: 'ai-assistant', label: 'AI Assistant', path: '/ai-assistant' },
                        { id: 'market-data', label: 'Market Data', path: '/market-data' }
                    ]
                },
                {
                    section: 'Operations',
                    items: [
                        { id: 'alerts', label: 'Alerts', path: '/alerts' },
                        { id: 'reports', label: 'Reports', path: '/reports' },
                        { id: 'settings', label: 'Settings', path: '/settings' }
                    ]
                }
            ];
            
            // ============================================
            // Component: Main Application
            // ============================================
            
            function App() {
                const [isAuthenticated, setIsAuthenticated] = useState(!!TokenManager.getToken());
                const [currentPage, setCurrentPage] = useState('dashboard');
                const [user, setUser] = useState(TokenManager.getUser());
                const [sidebarOpen, setSidebarOpen] = useState(false);
                
                useEffect(() => {
                    // Check if user is authenticated on mount
                    const token = TokenManager.getToken();
                    const savedUser = TokenManager.getUser();
                    if (token && savedUser) {
                        setIsAuthenticated(true);
                        setUser(savedUser);
                    }
                    
                    // Listen for navigation events
                    const handleNavigate = (event) => {
                        if (event.detail && event.detail.page) {
                            setCurrentPage(event.detail.page);
                        }
                    };
                    window.addEventListener('navigate', handleNavigate);
                    
                    return () => {
                        window.removeEventListener('navigate', handleNavigate);
                    };
                }, []);
                
                const handleLogin = (userData) => {
                    setIsAuthenticated(true);
                    setUser(userData);
                    setCurrentPage('dashboard');
                };
                
                const handleLogout = () => {
                    TokenManager.removeToken();
                    TokenManager.removeUser();
                    // Clear portfolio selection from localStorage
                    localStorage.removeItem('selectedPortfolioId');
                    setIsAuthenticated(false);
                    setUser(null);
                    setCurrentPage('dashboard');
                };
                
                const toggleSidebar = () => {
                    setSidebarOpen(!sidebarOpen);
                };
                
                const renderPage = () => {
                    switch(currentPage) {
                        case 'dashboard':
                            return e(DashboardPage);
                        case 'holdings':
                            return e(HoldingsPage);
                        case 'security-detail':
                            return e(SecurityDetailPage);
                        case 'transactions':
                            return e(TransactionsPage);
                        case 'performance':
                            return e(PerformancePage);
                        case 'macro-cycles':
                            return e(MacroCyclesPage);
                        case 'scenarios':
                            return e(ScenariosPage);
                        case 'risk':
                            return e(RiskPage);
                        case 'attribution':
                            return e(AttributionPage);
                        case 'optimizer':
                            return e(OptimizerPage);
                        case 'ratings':
                            return e(RatingsPage);
                        case 'ai-insights':
                            return e(AIInsightsPage);
                        case 'ai-assistant':
                            return e(AIAssistantPage);
                        case 'alerts':
                            return e(AlertsPage);
                        case 'reports':
                            return e(ReportsPage);
                        case 'corporate-actions':
                            return e(CorporateActionsPage);
                        case 'market-data':
                            return e(MarketDataPage);
                        case 'settings':
                            return e(SettingsPage);
                        default:
                            return e('div', null, 'Page not found');
                    }
                };
                
                if (!isAuthenticated) {
                    return e(LoginPage, { onLogin: handleLogin });
                }
                
                return e(UserContextProvider, { user },
                    e('div', { className: 'dashboard' },
                        // Sidebar
                        e('aside', { className: `sidebar ${sidebarOpen ? 'open' : ''}` },
                        e('div', { className: 'sidebar-header' },
                            e('div', { className: 'sidebar-brand' }, 'DawsOS')
                        ),
                        e('nav', { className: 'sidebar-nav' },
                            navigationStructure.map(section =>
                                e('div', { key: section.section, className: 'nav-section' },
                                    e('div', { className: 'nav-section-title' }, section.section),
                                    section.items.map(item =>
                                        e('button', {
                                            key: item.id,
                                            className: `nav-item ${currentPage === item.id ? 'active' : ''}`,
                                            onClick: () => {
                                                setCurrentPage(item.id);
                                                setSidebarOpen(false);
                                            }
                                        }, item.label)
                                    )
                                )
                            )
                        )
                    ),
                    
                    // Main Content
                    e('div', { className: `main-wrapper ${!sidebarOpen ? '' : 'expanded'}` },
                        // Header
                        e('header', { className: 'header-bar' },
                            e('div', { className: 'header-left' },
                                e('button', { 
                                    className: 'menu-toggle',
                                    onClick: toggleSidebar
                                }, '☰'),
                                e('div', { className: 'breadcrumb' },
                                    e('span', null, 'DawsOS'),
                                    e('span', { className: 'breadcrumb-separator' }, '/'),
                                    e('span', { className: 'breadcrumb-current' }, 
                                        navigationStructure.flatMap(s => s.items)
                                            .find(i => i.id === currentPage)?.label || 'Dashboard')
                                )
                            ),
                            e('div', { className: 'header-right' },
                                e(PortfolioSelector),
                                e('div', { className: 'user-info' }, user?.email || 'User'),
                                e('button', { 
                                    className: 'btn-logout',
                                    onClick: handleLogout
                                }, 'Logout')
                            )
                        ),
                        
                        // Page Content
                        e('main', { className: 'page-content' },
                            renderPage()
                        )
                    )
                    )
                );
            }

            // Wrap the App with ErrorBoundary and render the application
            ReactDOM.render(
                e(ErrorBoundary, null, e(App)),
                document.getElementById('root')
            );
        }
    </script>
</body>
</html>