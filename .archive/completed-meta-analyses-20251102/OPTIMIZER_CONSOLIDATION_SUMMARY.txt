================================================================================
OPTIMIZER AGENT → FINANCIAL ANALYST CONSOLIDATION ANALYSIS
================================================================================
Date: 2025-11-03
Analysis Duration: ~20 minutes (MEDIUM thoroughness)
Repository: /Users/mdawson/Documents/GitHub/DawsOSP

================================================================================
SCOPE
================================================================================

This analysis covers the 4 methods from OptimizerAgent that will be consolidated
into FinancialAnalyst:

1. optimizer_propose_trades()           (Lines 63-233, 171 lines)
2. optimizer_analyze_impact()           (Lines 235-349, 115 lines)
3. optimizer_suggest_hedges()           (Lines 351-456, 106 lines)
4. optimizer_suggest_deleveraging_hedges() (Lines 458-593, 136 lines)

Total OptimizerAgent: 592 lines
Total OptimizerService: 1,558 lines
Total: 2,150 lines of code

================================================================================
KEY FINDINGS
================================================================================

CONSOLIDATION DIFFICULTY: LOW ✓

All 4 methods follow the same architectural pattern:
  1. Resolve parameters from context/state/params
  2. Validate required inputs (portfolio_id, pricing_pack_id)
  3. Call corresponding OptimizerService method
  4. Attach metadata and return result

The consolidation is straightforward because:
  - No direct database access in agent layer (all delegated to service)
  - Stateless service (can be shared between agents)
  - Consistent error handling pattern
  - Clear separation of concerns (agent = routing, service = logic)

IMPLEMENTATION TIME ESTIMATE: 2-4 hours

Includes:
  - Copying and adapting 4 methods
  - Testing parameter resolution
  - Updating documentation
  - Verifying pattern compatibility

================================================================================
CRITICAL DEPENDENCIES
================================================================================

SACRED INVARIANT:
  - pricing_pack_id MUST be in RequestCtx
  - Used for reproducibility and traceability
  - Non-negotiable - raises ValueError if missing

EXTERNAL SERVICES:
  - OptimizerService (primary, already exists)
  - ScenarioService (used by suggest_hedges)
  - RatingsService (optional, for quality filtering)

DATABASE TABLES:
  - lots (portfolio positions)
  - prices (security prices by date)
  - pricing_packs (pack metadata)

EXTERNAL LIBRARIES:
  - Riskfolio-Lib (for portfolio optimization)
    - Supports: Mean-Variance, Risk Parity, Max Sharpe, CVaR
    - Uses 252-day historical lookback

================================================================================
METHOD SUMMARIES
================================================================================

METHOD 1: optimizer_propose_trades()
  Purpose: Generate rebalance trades based on policy constraints
  Service: OptimizerService.propose_trades()
  Cache TTL: 0 (no caching - always fresh)
  
  Input Validation:
    - Portfolio ID resolution (param → context)
    - Policy parameter consolidation (list/dict formats)
    - Pricing pack validation (context required)
    - Ratings extraction (state or param)
  
  Key Features:
    - Quality filtering (exclude low-rated securities)
    - Turnover constraint enforcement
    - Trade cost estimation (commission + market impact)
    - Constraint scaling if optimization exceeds limits

METHOD 2: optimizer_analyze_impact()
  Purpose: Analyze before/after metrics of proposed trades
  Service: OptimizerService.analyze_impact()
  Cache TTL: 0 (no caching)
  
  Input Validation:
    - Portfolio ID resolution
    - Multi-location proposed_trades search (3 possible locations)
    - Pricing pack validation
  
  Key Features:
    - Portfolio value delta calculation
    - Concentration metric (top 10 holdings %)
    - Trade simulation
    - TODO: Sharpe ratio, volatility, max drawdown (not yet implemented)

METHOD 3: optimizer_suggest_hedges()
  Purpose: Recommend hedges for scenario stress tests
  Service: OptimizerService.suggest_hedges() → ScenarioService
  Cache TTL: 3600 (1-hour cache)
  
  Input Validation:
    - Portfolio ID resolution
    - Scenario ID extraction (multiple dict key variants)
    - Pricing pack validation
  
  Key Features:
    - 10+ scenario type mappings (rates_up, equity_selloff, usd_up, etc.)
    - Instrument type support (equity, option, futures, ETF)
    - Expected offset percentage (hedge effectiveness estimate)
    - Scenario-specific hedge playbooks

METHOD 4: optimizer_suggest_deleveraging_hedges()
  Purpose: Regime-specific deleveraging recommendations (Dalio playbook)
  Service: OptimizerService.suggest_deleveraging_hedges()
  Cache TTL: 3600 (1-hour cache)
  
  Input Validation:
    - Portfolio ID resolution
    - Regime resolution (multi-source with priority)
      1. Direct regime parameter
      2. LTDC phase mapping (Phase 1-4 → regime)
      3. Scenario inference (find max impact)
      4. State extraction (from macro.detect_regime)
  
  Key Features:
    - 3 main regimes: DELEVERAGING/DEPRESSION, LATE_EXPANSION, REFLATION
    - Specific instrument recommendations per regime
    - Reduction/allocation percentages
    - Rationale for each recommendation

================================================================================
PATTERN COMPATIBILITY
================================================================================

All 4 methods support pattern-compatible parameter names:

optimizer_propose_trades:
  - policies: List or dict format (type-based conversions)
  - constraints: Dict with max_turnover_pct, max_te_pct, min_lot_value
  - positions: Caller-supplied (avoids DB query)

optimizer_analyze_impact:
  - proposed_trades searches state["proposed_trades"] 
    and state["rebalance_result"]["trades"]

optimizer_suggest_hedges:
  - scenario_result: Dict with scenario metadata
    (supports scenario_id, id, scenario_type, name keys)

optimizer_suggest_deleveraging_hedges:
  - ltdc_phase: LTDC cycle phase (maps to regime)
  - scenarios: Dict of scenario results (infers regime from max impact)

================================================================================
ERROR HANDLING STRATEGY
================================================================================

All 4 methods use consistent error handling:

1. Try service call
2. Catch all exceptions
3. Log error with traceback (exc_info=True)
4. Return empty/zero result with error string
5. Always attach metadata (even on error)

Empty Result Structures:
  - propose_trades: trades=[], trade_count=0, constraints_met=False
  - analyze_impact: current_value=0, post_rebalance_value=0, value_delta=0
  - suggest_hedges: hedges=[], total_notional=0, expected_offset_pct=0
  - suggest_deleveraging_hedges: recommendations=[]

================================================================================
LOGGING PATTERNS
================================================================================

Entry Point (INFO):
  logger.info(f"optimizer.METHOD_NAME: portfolio_id={id}, pricing_pack_id={pack}")

Success Metrics (INFO):
  logger.info(f"Generated {count} proposals, turnover={pct:.1f}%, costs={bps:.1f}bps")

Data Issues (WARNING):
  logger.warning(f"No positions found for portfolio {id}")
  logger.warning(f"Riskfolio-Lib not available. Using stub mode.")
  logger.warning(f"Turnover {pct:.1f}% exceeds {max_pct}%")

Errors (ERROR with traceback):
  logger.error(f"METHOD_NAME failed: {e}", exc_info=True)

Logger Name:
  "DawsOS.OptimizerAgent" → "DawsOS.FinancialAnalyst" (after consolidation)

================================================================================
SERVICE LAYER INTEGRATION
================================================================================

OptimizerService Methods (async):

  propose_trades(
    portfolio_id: UUID,
    policy_json: Dict,
    pricing_pack_id: str,
    ratings: Optional[Dict[str, float]],
    positions: Optional[List[Dict]],
    use_db: bool,
  ) → Dict with trades, metrics, metadata

  analyze_impact(
    portfolio_id: UUID,
    proposed_trades: List[Dict],
    pricing_pack_id: str,
  ) → Dict with before/after metrics

  suggest_hedges(
    portfolio_id: UUID,
    scenario_id: str,
    pricing_pack_id: str,
  ) → Dict with hedge recommendations

  suggest_deleveraging_hedges(
    portfolio_id: UUID,
    regime: str,
    pricing_pack_id: str,
  ) → Dict with regime-specific recommendations

Service Acquisition:
  from app.services.optimizer import get_optimizer_service
  optimizer_service = get_optimizer_service()

================================================================================
HELPER METHODS (OptimizerService)
================================================================================

Core Optimization:
  - _parse_policy(): JSON → PolicyConstraints dataclass
  - _fetch_current_positions(): Load from lots table
  - _fetch_price_history(): Historical prices for covariance (252-day lookback)
  - _run_optimization(): Riskfolio-Lib wrapper (via asyncio.to_thread)
  - _optimize_sync(): Synchronous Riskfolio kernel
  - _equal_weight_fallback(): Fallback when optimization fails

Trade Generation:
  - _filter_by_quality(): Filter positions by quality rating
  - _generate_trade_proposals(): Target weights → trade proposals
  - _estimate_trade_cost(): Commission + market impact calculation
  - _scale_trades_to_turnover_limit(): Proportional scaling for constraints

Impact Analysis:
  - _simulate_trades(): Apply trades to positions
  - _calculate_concentration_top10(): Top 10 holdings percentage

Hedging & Deleveraging:
  - _get_scenario_hedges(): Scenario-specific hedge playbook
  - _get_deleveraging_recommendations(): Regime-specific recommendations

Utilities:
  - _get_pack_date(): Get asof_date from pricing pack
  - _dataclass_to_dict(): Type-aware dataclass conversion
  - _empty_rebalance_result(): Empty result (no positions)
  - _stub_rebalance_result(): Stub result (Riskfolio not installed)
  - _empty_impact_analysis(): Empty impact analysis

Testing:
  - _mock_execute_query(): Mock database (testing mode)
  - _mock_execute_query_one(): Mock single-row query
  - _mock_execute_statement(): Mock statement execution

================================================================================
POTENTIAL ISSUES & MITIGATION
================================================================================

Issue 1: Riskfolio-Lib Not Installed
  Severity: MEDIUM
  Impact: Returns stub trades (no optimization)
  Mitigation: Check riskfolio_available flag, return helpful warning

Issue 2: Insufficient Price History
  Severity: MEDIUM
  Impact: Falls back to equal-weight optimization
  Behavior: Returns zero-trade result with warning
  Mitigation: Verify 30+ days of data available

Issue 3: Constraint Violations (Turnover Exceeded)
  Severity: LOW
  Impact: Trades are scaled down proportionally
  Behavior: Adds warning, adjusts targets
  Mitigation: Final weights may not achieve target

Issue 4: Quality Filtering Excludes All Positions
  Severity: LOW
  Impact: Returns empty trades
  Behavior: Logs info about excluded positions
  Mitigation: Check policy quality threshold

Issue 5: State Dict Structure Variability
  Severity: LOW
  Impact: Parameter resolution may fail if state format unexpected
  Mitigation: Search multiple locations, clear error messages

Issue 6: Async/Thread Blocking (Riskfolio)
  Severity: LOW
  Impact: Large portfolios may block thread pool
  Behavior: Uses asyncio.to_thread for synchronous code
  Mitigation: Monitor thread pool utilization

Issue 7: analyze_impact Incomplete
  Severity: LOW
  Impact: Sharpe, volatility, max DD not calculated
  Status: TODO in source code
  Mitigation: Fields return None/omitted

================================================================================
CONSOLIDATION CHECKLIST
================================================================================

Pre-Implementation:
  [ ] Verify OptimizerService dependency available
  [ ] Confirm all database tables exist
  [ ] Test Riskfolio-Lib installation
  [ ] Review existing FinancialAnalyst implementation

Code Migration:
  [ ] Copy 4 method signatures to FinancialAnalyst
  [ ] Rename methods (optimizer_* → financial_analyst_*)
  [ ] Update logger prefix ("DawsOS.OptimizerAgent" → "DawsOS.FinancialAnalyst")
  [ ] Update capability names in get_capabilities()
  [ ] Verify OptimizerService injected as service dependency

Testing:
  [ ] Test parameter resolution (all input variants)
  [ ] Test pricing_pack_id validation
  [ ] Test error handling (empty results)
  [ ] Test metadata attachment (TTL values)
  [ ] Test with missing optional parameters (ratings, positions)
  [ ] Test pattern compatibility (policies, constraints, scenario_result)
  [ ] Test state dict parameter extraction

Documentation:
  [ ] Update FinancialAnalyst docstring
  [ ] Document new capabilities in get_capabilities()
  [ ] Add examples to docstring
  [ ] Document parameter resolution priority

Backward Compatibility:
  [ ] Consider dual-registration (optimizer.* → financial_analyst.*)
  [ ] Plan deprecation timeline for OptimizerAgent
  [ ] Update any dependent code/patterns

================================================================================
ADDITIONAL RESOURCES
================================================================================

Detailed Analysis: OPTIMIZER_AGENT_ANALYSIS.md (881 lines)
  - Full method signatures with return types
  - Complete service dependencies
  - Database queries
  - Input validation patterns
  - Error handling details
  - Business logic flows
  - Code snippets for complex logic

Code Patterns Guide: CONSOLIDATION_CODE_PATTERNS.md
  - 10 key code patterns
  - Implementation examples
  - TTL strategy
  - Return structure templates
  - Logging best practices
  - Implementation checklist

Files Analyzed:
  /Users/mdawson/Documents/GitHub/DawsOSP/backend/app/agents/optimizer_agent.py
  /Users/mdawson/Documents/GitHub/DawsOSP/backend/app/agents/financial_analyst.py
  /Users/mdawson/Documents/GitHub/DawsOSP/backend/app/services/optimizer.py
  /Users/mdawson/Documents/GitHub/DawsOSP/backend/app/agents/base_agent.py

================================================================================
CONCLUSION
================================================================================

The OptimizerAgent consolidation into FinancialAnalyst is a straightforward
refactoring with low technical risk. All 4 methods follow consistent patterns
and delegate complex logic to OptimizerService.

Key Success Factors:
  1. Preserve parameter resolution logic (multi-source handling)
  2. Maintain error handling consistency
  3. Ensure OptimizerService dependency availability
  4. Test pattern compatibility (policies, constraints, scenario_result)
  5. Verify metadata attachment (TTL values)

Estimated Implementation Time: 2-4 hours
Estimated Testing Time: 2-3 hours
Risk Level: LOW

The consolidation will simplify the agent architecture while maintaining full
backward compatibility and functionality.

